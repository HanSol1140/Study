<설치이후 화면이 출력되면 - 설치된 SD카드를 받아버려서 이전과정을 모름>
터미널을 열고 다음 명령을 실행하여 패키지 관리자를 업데이트
sudo apt update
다음 명령을 사용하여 필요한 의존성 패키지를 설치
sudo apt install -f
<VS Code를 설치>
sudo apt install code
    설치 과정에서 계속 멈추므로 몇번씩 다시입력해보세요
    설치가 다됬다면 터미널에 code 입력
<node.js설치>
    <홈 경로에 노드 최신파일을 받습니다>
        nodejs 홈페이지 - 다운로드 ARMv7 다운로드 (홈경로)
        node-v18.16.1-linux-armv7l.tar.xz파일 압축해제
        터미널을켜서
        echo 'export PATH=$HOME/node-v18.16.1-linux-armv7l/bin:$PATH' > ~/.bashrc
        source ~/.bashrc
        
        버전확인
        node -v
        npm -v

        설정한 경로 확인방법
        which node
        which npm

        reboot해주세요

<포트 데이터를 읽기위해 minicom 설치>
sudo apt-get install minicom

미니컴 실행
sudo minicom -b 9600 -o -D /dev/ttyUSB0
신호 보내기 - 터미널을 하나 더켜서
echo "Hello, World!" > /dev/ttyUSB0

<특정 포트에 번호판이 연결되엇는지 체크>
이경우엔 usb로 연결되었으므로
lsusb를 통해 리스트를확인하고
usb를 뽑아봄으로써 2303이라는걸 확인할 수 잇음
ID:067b:2303
<RS485 WG26/34 USB컨버터 값받기>
    좌측상단 라즈베리파이 기본설정 - rassberry Pi Configuration - interfaces 에서 SSH,I2C등 통신을 가능하게 설정
    <파이썬>
            <파이썬 pyserial 라이브러리설치>
            pip install pyserial
            
            <파이썬 코드>
            import serial

            # 시리얼 장치 연결
            # 보레이트 9600, 장치 위치 ttyUSB0
            ser = serial.Serial('/dev/ttyUSB0', 9600, timeout=5)
            
            def run():
                # 시리얼 쓰기
                ser.write(bytes(bytearray([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15])))
                while True:
                    # 시리얼 읽기 (5바이트씩 읽음)
                    line = ser.read(15)
                    if len(line) == 0:
                        break
                    # 헥사 코드로 출력
                    hex_list = ["{:02x}".format(c) for c in line]
                    print(' '.join(hex_list))
                    # 10진수로 출력
                    decimal_list = [str(c) for c in line]
                    print(' '.join(decimal_list))
                    # 아스키 코드로 출력
                    ascii_list = [chr(c) for c in line]
                    print(' '.join(ascii_list))
            
            while True:
                run()

            <02 0d 0a 03이  아스키 코드로변환시 공백이 되는이유는?>
                0d, 0a, 03과 같은 값들은 아스키 코드에서 제어 문자(Control Character)에 해당합니다. 아스키 코드에서 제어 문자는 일반적인 출력 문자가 아니라 특정 제어 기능을 수행하는 문자입니다.

                02: STX (Start of Text) - 텍스트 시작을 나타내는 제어 문자입니다.
                0d: CR (Carriage Return) - 커서를 행의 시작 위치로 이동시키는 제어 문자입니다.
                0a: LF (Line Feed) - 커서를 다음 행으로 이동시키는 제어 문자입니다.
                03: ETX (End of Text) - 텍스트의 끝을 나타내는 제어 문자입니다.
                이러한 제어 문자들은 출력되는 문자 그 자체로는 시각적으로 표현되지 않고, 특정 동작을 수행합니다. 따라서 이 값들을 아스키 코드로 변환하면 공백으로 표시되는 것입니다.

                만약 제어 문자에 해당하는 값을 출력하고자 한다면, chr() 함수를 사용하여
                아스키 코드 문자로 변환하기 전에 해당 값을 그대로 출력할 수 있습니다.
                예를 들어, print(' '.join(str(c) for c in line))와 같이 코드를 수정하면
                제어 문자에 해당하는 값들도 숫자 그대로 출력됩니다.

    <express서버로 수정>
        <serialport설치>
            npm install serialport
        <코드>
            // 번호 키 입력받기
            const { SerialPort, ReadlineParser } = require('serialport');
            const { CLIENT_RENEG_LIMIT } = require('tls');
            let serialPort = new SerialPort({ path: '/dev/ttyUSB0', baudRate: 9600});

            // Send data through serial port
            let dataToSend = Buffer.from([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15]);
            serialPort.write(dataToSend);

            let parser = new ReadlineParser();
            serialPort.pipe(parser);

            parser.on('data', function(data) {
                let phoneNumber1 = data[1]+data[2]+data[3];
                let phoneNumber2 = data[4]+data[5]+data[6]+data[7];
                let phoneNumber3 = data[8]+data[9]+data[10]+data[11];
                console.log(data);
            });
    
    
    