코드부분은 보기 어렵다면 인텔리제이로 실행해서 보는것을 권장

───────────────────────────────────────────────────────────────────────────────────────────────

<변수의 타입>

    <숫자>
        int / long
            정수(integer)를 저장하기 위한 타입(20억이 넘을 땐 long)
        
        float / double
            (floating-point number)를 저장하기 위한 타입(float는 오차없이 7자리, double은 15자리)
    <문자>
        char
            문자(character)를 지정하기 위한 타입
            
        String
            여러 문자(문자열, string)를 저장하기 위한 타입
───────────────────────────────────────────────────────────────────────────────────────────────
<지시자>
public class Main {
    public static void main(String[] args){
        System.out.printf("Age:%d", 14);
        <!-- // System.out.println("Age:%d", 14); <= println은 불가능 -->
        
        <!-- %d를 사용하여 변수의 값을 지정된 형식으로 변환해서 사용가능하다, -->
        <!-- 이때 출력될 값과 지시자의 순서는 일치해야 한다. -->
    }
}

<지시자의 종류>
    %d
        10진(decimal) 정수의 형식으로 출력
    %x
        16진(hexa-decimal) 정수의 형식으로 출력
    %f
        부동 소수점(floating- point)의 형식으로 출력
    %c
        문자(character)로 출력
    %s
        문자열(string)로 출력

        더 많은 지시자는 검색으로 알아볼것
───────────────────────────────────────────────────────────────────────────────────────────────
<Scanner>
    import java.util.Scanner;
    // 스캐너 클래스를 사용하기 위해 추가

    public class Main {
        public static void main(String[] args) {

            Scanner scanner = new Scanner(System.in);
            System.out.print("두자리 정수를 하나 입력해주세요");
            String input = scanner.nextLine();
            int num = Integer.parseInt(input);
            System.out.println("입력내용 : " + input);
            System.out.printf("num = %d%n", num);

    //      형변환을 하지 않고 그대로 숫자받기
            Scanner scanner2 = new Scanner(System.in);
            System.out.print("두자리 정수를 하나 입력해주세요 ");
            Integer input2 = scanner2.nextInt(); // 바로 int형으로 받기
            System.out.println("입력내용 : " + input2);
            System.out.printf("num = %d%n", input2);
        }
    }
    
<!-- nextInt()나 nextFloat()으로 바로 숫자를 입력받을 수 있습니다 -->
───────────────────────────────────────────────────────────────────────────────────────────────
<if문>
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        int score = 0; // 학점을 저장하기 위한 변수
        char grade = ' '; // 학점을 저장하기 위한 변수, 공백으로 초기화 된다.
        System.out.print("학점을 입력하세요");
        Scanner scanner = new Scanner(System.in);
        score = scanner.nextInt(); // 화면을 통해 입력받은 숫자를 score에 저장
        if(score >= 90){ // score가 90점보다 같거나 크면 A학점
            grade = 'A';
        }else if(score >= 80){ // score가 80점 보다 같거나 크면 B학점
            grade = 'B'; 
        }else if(score >= 70){ // score가 70점보다 같거나 크면 C학점
            grade = 'C';
        }else{ // 나머지는 D학점
            grade = 'D';
        }
        System.out.println("당신의 학점은 " + grade + "입니다");
    }

}
───────────────────────────────────────────────────────────────────────────────────────────────
<switch문>
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        System.out.print("현재 월을 입력하세요");

        Scanner scanner = new Scanner(System.in);
        int month = scanner.nextInt();

        switch(month){
            case 3: 
            case 4: 
            case 5:
                System.out.println("현재 계절은 봄입니다.");
                break;
            case 6: case 7: case 8:
                System.out.println("현재 계절은 여름입니다.");
                break;
            case 9: case 10: case 11:
                System.out.println("현재 계절은 가을입니다.");
                break;
            case 12: case 1: case 2:
                System.out.println("현재 계절은 겨울입니다.");
                break;
        }

    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<for문>
public class Main {
    public static void main(String[] args) {
        System.out.println("***********");
        // ***********

        System.out.println("====================");

        for(var i = 0; i <= 10; i++){
            System.out.print("*");
        }
        // ***********

        System.out.println("\n====================");

        System.out.println("시작");
        for(var i = 1; i <= 5; i++){
            for(var j = 1; j <= i; j++) {
                System.out.print("*");
            }
            System.out.println();
        }
        // *
        // **
        // ***
        // ****
        // *****
    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<while문>
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // while(조건식){
        //     실행할코드
        // }
        int num = 0, sum = 0;
        System.out.println("숫자를 입력하세요(예:12345)");
        Scanner scanner = new Scanner(System.in);
        String tmp = scanner.nextLine();
        num = Integer.parseInt(tmp);
        while(num != 0){
            // num을 10으로 나눈 나머지를 sum에 더함
            sum += num % 10;
            System.out.printf("sum=%d num=%d\n", sum, num);
            num /= 10; // int형이기 때문에 0.1이되면 0을 반환함
        }

        // do-while문
        // ~의 결과가 조건식을 벗어날때까지 반복
        // 결과를 먼저 내고 조건식에 맞추기때문에 최소한 한번의 실행을 보장함

        int input = 0, answer = 0;
        answer = (int)(Math.random() * 100) + 1; // 1과 100사이의 임의의 숫자
        do{
            System.out.println("1과 100사이의 정수를 입력하세요");
            input = scanner.nextInt();

            if(input > answer){
                System.out.println(answer);
                System.out.println("더 적은 수로 다시 시도해보세요");
            }else if(input < answer){
                System.out.println(answer);
                System.out.println("더 큰수로 다시 시도해보세요");
            }
        }while(input != answer); // input과 answer값이 같아지면 반복문 종료

    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<Array>
import java.util.Arrays;

public class Main {
    public static void main(String[] args){

        int[] Arr1 = new int[10];
        int[] Arr2 = new int[10];
        // int[] Arr3 = new int[]{100, 95, 80, 70, 5};
        int[] Arr3 = {100, 95, 80, 70, 5};
        char[] chArr = {'a', 'b', 'c', 'd'};

        for(int i=0; i < Arr1.length; i++){
            Arr1[i] = i + 1; // 1~10의 숫자를 차례대로 배열에 넣는다.
        }
        for(int i = 0; i < Arr2.length; i++){
            Arr2[i] = (int)(Math.random() * 10) + 1; // 1 ~10의 값을 배열에 저장
        }

        // 배열에 저장된 값들을 출력
        for(int i = 0; i < Arr1.length; i++){
            System.out.println(Arr1[i]+",");
        }
        System.out.println();

        System.out.println(Arrays.toString(Arr2));
        System.out.println(Arrays.toString(Arr3));
        System.out.println(Arrays.toString(chArr));
        System.out.println(Arr3);
        System.out.println(chArr);

        // [2, 2, 10, 9, 4, 9, 5, 2, 3, 9]
        // [100, 95, 80, 70, 5]
        // [a, b, c, d]
        // [I@6d03e736
        // abcd

        System.out.println("============");

        // 최대값과 최소값
        int[] score = {79, 88, 91, 33, 100, 55, 95};

        int min = score[0];
        int max = score[0];

        for(int i = 1; i < score.length; i++){
            if(score[i] > max){
                max = score[i];
                System.out.println(score[i]);
            }else if(score[i] < min){
                min = score[i];
                System.out.println(score[i]);
            }
        }
        System.out.println("최대값 : " + max);
        System.out.println("최소값 : " + min);

        // 랜덤 로또번호 만들기;
        int[] ball = new int[45]; // 1 ~ 45의 정수값을 저장할배열생성

        // 생성한 배열에 1-45 숫자 담기
        for(int i = 0; i< ball.length; i++){
            ball[i] = i+1;
        }

        System.out.println("============");

        // 값 두개를 변경할때 사용할 임시 변수
        int temp = 0;
        int j = 0;


        for(int i = 0; i < 6; i++){
            j = (int)(Math.random() * 45); // 0 ~ 44 범위의 임의의 값을 얻는다
            temp = ball[i]; // 임시변수는 ball[i]다
            ball[i] = ball[j]; // ball[i]는 ball[j]다
            ball[j] = temp; // 랜덤수는 temp가되고 다시 반복문으로 돌아가서 랜덤수 = ball[i]가 된다
        }

        // 배열 ball의 앞에서부터 6개의 요소를 출력
        for(int i = 0; i < 6; i++){
            System.out.printf("ball[%d] = %d\n", i, ball[i]);
        }
    }
}
        <!--
        이 코드를 풀어서 설명하기
        앞의 숫자 6가지가 [12, 15, 11, 40, 46, 97]이라고 했을때
        1.
           임시변수(0)는 0번 배열이다이다,
           0번 배열은 12다
           12는 임시변수다.
        2.
           임시변수(12)는 1번 배열이다
           1번 배열은 15다
           15는 임시변수다
        3.
           임시변수(15)는 2번 배열이다
           2번 배열은 11이다
           11은 임시변수다.
        ...
        -->

        <!-- 이런식으로 하여금 앞자리 6개를 랜덤한 1~45의 숫자로 출력할 수 있습니다. -->


        <!-- ※ 별로 효율적인 방법은 아닌거같음 -->
        <!-- 7번째 반복이 이루어지지 않으면 6번째 숫자가 랜덤이 아닌점도 맘에 안듬    -->
        
        // System.out.println("============");
        // for(i = 0; i < 6; i++){
        //  System.out.println("ball["+i+"] = " + (int)((Math.random() * 45)+1));
        // }
            



───────────────────────────────────────────────────────────────────────────────────────────────
<String Array>
public class Main {
    public static void main(String[] args) {
        String[] name1 = new String[3];
        name1[0] = "Kim";
        name1[1] = "Park";
        name1[2] = "Yi";

        String[] name2 = new String[] {"Kim", "Park", "Yi"};
        String[] name3 = {"Kim", "Park", "Yi"};

        <!-- 원래 클래스는 new 연산자를 통해 객체를 생성해야하지만 -->
        <!-- String은 특별히 생략이 가능함 -->

        <!-- => 원래는 이런 방식으로 생성해야 합니다. -->
        String[] name4 = new String[3];
        name4[0] = new String("Kim");
        name4[1] = new String("Park");
        name4[2] = new String("Yi");


    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<2차원 배열>
public class Main {
    public static void main(String[] args) {
        int[][] score = {
                { 100, 100, 100},
                { 20, 20, 20 },
                { 30, 30, 30 },
                { 40, 40, 40 },
                { 50, 50, 50 }
        };

        int korTotal = 0, engTotal = 0, mathTotal = 0;

        System.out.println("번호 국어 영어 수학 총점 평균");
        System.out.println("=========================");

        for(int i=0; i < score.length; i++){
            int sum = 0;
            float avg = 0;

            korTotal += score[i][0];
            engTotal += score[i][1];
            mathTotal += score[i][2];
            System.out.printf("%2d", i+1);

            for(int j=0; j < score[i].length; j++){
                sum += score[i][j];
                System.out.printf("%5d", score[i][j]);
            }

            avg = sum/(float)score[i].length;
            System.out.printf("%5d %5.1f\n", sum, avg);
        }
        System.out.println("=========================");
        System.out.printf("총점 : 국어 %3d 영어 %3d 수학 %3d\n", korTotal, engTotal, mathTotal);


        <!--
        1  100  100  100  300 100.0
        2   20   20   20   60  20.0
        3   30   30   30   90  30.0
        4   40   40   40  120  40.0
        5   50   50   50  150  50.0
       =========================
       총점 : 국어 240 영어 240 수학 240
        -->



    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<객체지향 언어>
    1. 코드의 재사용성이 높다.
        새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.

    2. 코드의 관리가 용이하다.
        코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.

    3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
        제어자와 메서드를 이용하여 데이터를 보호하고 올바른 값을 유지하도록 하며,
        코드의 중복을 제거하여 코드불일치로 인한 오동작을 방지한다.

    앞으로 객체지향개념을 배울때
        코드의 재사용성
        유지보수
        중복된 코드의 제거

    이 세가지를 중점적으로 보면 보다 쉽게 이해할 수 있다.
───────────────────────────────────────────────────────────────────────────────────────────────
<클래스(Class)와 객체(Object)>
<!-- ObjectAndClass1 -->

 public class Main {
    public static void main(String[] args) {

// 2. 인스턴스를 생성
        Tv t;             // Tv 객체를 참조하기 위한 변수 t 선언
        t = new Tv();     // Tv인스턴스를 생성한다.

// 3. 사용
        t.channel = 7;    // Tv인스턴스의 멤버변수 channel의 값을 7로 한다.
        t.channelDown();  // Tv인스턴스의 메서드 channelDown()을 호출한다.
        System.out.println("현재 채널은" + t.channel + " 입니다.");

// 4. 멤버변수 직접 수정
        t.channel = 111;
        System.out.println("t의 channel값을 111로 변경하였습니다.");

    }
}

// 1. Tv 클래스를 선언한다
class Tv{

    // Tv의 속성(멤버변수)
    String color;       // 색상
    boolean power;      // 전원상태(on/off)
    int channel;        // 채널

    // Tv의 기능(메서드)
    void power() { power = !power; }    // Tv를 켜거나 끄는 기능을 하는 메서드
    void channelUp() { ++channel; }     // Tv의 채널을 높이는 기능을 하는 메서드
    void channelDown() { --channel; }   // Tv의 채널을 낮추는 기능을 하는 메서드
}

/**
<!--

    이 예제는 TV클래스로부터 인스턴스를 생성하고, 인스턴스의 속성과 메서드를 사용하는 방법을 보여줍니다.

    Tv t;
    Tv클래스 타입의 참조변수 t를 선언합니다.
    메모리에 참조변수 t를 위한 공간이 마련됩니다.
    아직 인스턴스가 생성되지 않았으므로, 이 참조변수로 할수 있는것은 아무것도 없습니다

    t = new Tv();
    연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성된다.
    주소가 0x100인 곳에 생성되었다고 가정한다면, 이 때 멤버변수는 각 자료형에 해당하는 기본값으로 초기화된다.
    color는 참조형이므로 null,
    power는 boolean이므로 false,
    channel은 int이므로 0으로 초기화된다.

    t.channel = 7;
    참조변수 t에 저장된 주소에 있는 인스턴스의 멤버변수 channel에 7을 저장한다.
    여기서 알 수 있는것처럼, 인스턴스의 멤버변수(속성)를 사용하려면 '참조변수.멤버변수'와 같이 사용할 수 있다.

    t.channelDown();
    참조변수 t가 참조하고 있는 Tv인스턴스의 channelDown메서드를 호출하여
    멤버변수 channel에 저장되어있는 값을 1 감소시킨다.
 -->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<Class - 데이터와 함수>
클래스는 '객체를 생성하기 위한 틀'이며 클래스느 '속성과 기능'으로 정의되어있습니다.
이것은 객체지향의 관점에서 내린 정의이고, 이번엔 프로그래밍적인 관점에서 클래스의 정의를 알아봅시다.

    1. 변수
        하나의 데이터를 저장할 수 있는 공간

    2. 배열
        같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간

    3. 구조체(structure)
        서로관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간

    4. 클래스
        데이터와 함수의 결합(구조체 + 함수)


하나의 데이터를 저장하기 위해 변수를

그리고 같은 종류의 데이터를 보다 효율적으로 다루기 위해서 배열이라는 개념을 도입햇으며

후에는 구조체(structure)가 등장하여

자료형의 종류에 상관없이 서로 관계가 깊은 변수들을 하나로 묶어서 다룰 수 있도록 했습니다.


그동안은 데이터와 함수가 서로 관계가 없는 것처럼

데이터는 데이터끼리, 함수는 함수끼리 따로 다루어져 왔지만,

사실 함수는 주로 데이터를 가지고 작업을 하기 때문에 데이터와 함수는 관계가 깊습니다.



그래서 자바와 같은 객체지향언어에서는 변수(데이터)와 함수를 하나의 클래스에 정의하여

서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있게 했습니다.


이렇게 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이 클래스입니다.

<!-- 중요한 부분? -->
C언어에서는 문자열을 문자의 배열로 다루지만, 자바에서는 String이라는 클래스로 문자열을 다룹니다.
문자열을 단순한 문자의 배열로 정의하지 않고 클래스로 정의한 이유는
문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서입니다.
───────────────────────────────────────────────────────────────────────────────────────────────
<Private>
    public class Main {
        private int hour;
        private int minute;
        private float second;

        public void setHour(int h){
            if(h < 0 || h > 23) return;
            hour = h;
        }
    /**
    <!--
        // private 제어자를 통해서 변수의 값을 직접 변경하지 못하게 하고,
        // 대신 메서드를 통해서 값을 변경하게 만듭니다.
        // 이후 값을 변경할 때 지정된 값의 유효성을 조건문으로 점검한 다음에 유효한 값일 경우에만 변경합니다.
    
        //캡슐화
            // 변수에 직접 접근하는 것을 제한하여 변수의 값을 보호하고, 클래스 외부에서의 부적절한 접근을 방지합니다.
            // 이는 코드의 안정성과 유지보수성을 높입니다.
    
        // 유효성 검사
            // setter를 사용하여 변수의 값을 변경할 때, 특정 조건을 검사하고 유효한 값만 변수에 저장할 수 있습니다.
            // 이를 통해 변수에 유효하지 않은 값이 저장되는 것을 방지할 수 있습니다.
    
        // 코드 변경 유연성
            // 변수에 직접 접근하지 않고 getter와 setter를 사용하면, 내부 구현을 변경하거나 추가적인 로직을 적용하기 쉬워집니다.
            // 예를 들어, 변수 값을 가져올 때 특정 조건에 따라 가공한 값을 반환하거나, 변수 값을 변경하기 전에 로깅 또는 이벤트 처리를 추가할 수 있습니다.
    -->
    **/
        public static void main(String[] args) {
    
        }
    }

    
───────────────────────────────────────────────────────────────────────────────────────────────
<클래스 변수와 인스턴스 변수>
<!-- ObjectAndClass2 -->

public class Main {

    public static void main(String[] args) {

        System.out.println("Card.width = " + Card.width);
        System.out.println("Card.width = " + Card.height);


        Card c1 = new Card();
        c1.kind = "Heart";
        c1.number = 7;


        Card c2 = new Card();
        c2.kind = "spade";
        c2.number = 4;


        System.out.println(
                "c1은" + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")"
        ); /** c1은Heart, 7이며, 크기는 (100, 250) **/

        System.out.println(
                "c2은" + c1.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")"
        ); /** c2은Heart, 4이며, 크기는 (100, 250) **/

        /** <!-- 중요!! --> **/
        /** <!-- 클래스 변수의 값을 변경합니다 --> **/
        c1.width = 50;
        c1.height = 80;

        System.out.println(
                "c1은" + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")"
        ); /** c1은Heart, 7이며, 크기는 (50, 80) **/

        System.out.println(
                "c2은" + c1.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")"
        ); /** c2은Heart, 4이며, 크기는 (50, 80) **/

        /**
        <!--
            c1의 width값을 바꿧지만 c2의 width값까지 바뀌는 이유는
            width,height가 Card클래스의 변수이기 때문입니다.
            Card의 인스턴스인 c1과 c2는 클래스 변수(static)인 width와 height를 공유하기 때문에
            c1의 width(height)를 변경하면 c2의 width(height)도 바뀐 것과 같은 결과를 얻습니다.
            
            이러한 이유때문에 클래스 변수를 사용할 때는 클래스명.클래스변수의 형태로 사용하는 것이 좋습니다.
        -->
        **/


    }
}

class Card {
    String kind;
    int number;
    static int width = 100;
    static int height = 250;
}

/**
<!--
    이 함수를 public static void main(String[] args) {
    위에 올려서 Main 위로 올린뒤로 클래스를 미리 보여서 가독성을 높이려고 시도했는데 안되는것을 발견
    이는 static클래스를 선언할 시 인스턴스를 생성할 수 없기때문이라고 합니다.

    static?
        static int width = 100; / static int height = 250; <= static이므로
        Card c1 = new Card(); <= 이것과 같이 인스턴스를 생성할 수 없음
    
    그 대신, static선언한 변수는 인스턴스를 생성하지 않아도 Card.weight처럼 사용할 수 잇습니다.

    또한 반대로 static을 빼버리고 int width = 100; 처럼 선언할시 내부에 선언하여 인스턴스를 만들 수 있습니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<Method>
    public class Main {
        public static void main(String[] args) {
            MyMath mm = new MyMath(); // 인스턴스 생성
            long result1 = mm.add(5, 3);
            long result2 = mm.subStract(5, 3);
            long result3 = mm.multiply(5, 3);
            double result4 = mm.divide(5, 3); // long타입은 소수점을 출력할 수 없기 때문에 double로 선언
    
            System.out.println("add(5, 3) = " + result1);
            System.out.println("subStract(5, 3) = " + result2);
            System.out.println("multiply(5, 3) = " + result3);
            System.out.println("divide(5, 3) = " + result4);
    
            <!-- 이런식으로 바로 호출해서 사용할 수도 있습니다. -->
            System.out.println(mm.add(5,3));
    
    
        }
    }
    /** <!-- 사칙연산을 위한 4개의 메서드 MyMath --> **/
    class MyMath{
        int c = 0;
        long add(long a, long b){ // 더하기
            long result = a + b;
            return result;

            /**
            <!--
                return a + b;
                위의 두줄을 이와 같이 한 줄로 간단히 할 수 있다.
            -->
            **/
        }
        long subStract(long a, long b){ // 빼기
            return a - b;
        }
        long multiply(long a, long b){ // 곱하기
            return a * b;
        }
        double divide(double a, double b){ // 나누기
            return a / b;
        }
    }

───────────────────────────────────────────────────────────────────────────────────────────────
<CallStack>
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello!");
    }
}
/**
<!--
    1. 위의 예제를 실행시키면 JVM에 의해서 main 메서드가 호출됨으로써 프로그램이 시작됩니다.

            │               │
            │               │
            │               │
            │               │
            └───────────────┘


    2. 이때, 호출스택에서는 AMIN 메서드를 위한 메모리 공간이 할당되고 main메서드의 코드가 수행되기 시작한다
            │               │
            │               │
            │               │
            │      main     │
            └───────────────┘


    3. main 메서드에서 println()을 호출한 상태. 아직 main 메서드가 끝난 것이 아니므로,
        main 메서드는 호출스택에 대기상태로 남아있고 println()의 수행이 시작된다.
        println메서드에 의해 hello가 화면에 출력된다.
            │               │
            │               │
            │    println    │
            │     main      │
            └───────────────┘


    4. println메서드의 수행이 완료되어 호출스택에서 사라지고, 자신을 호출한 main메서드로 되돌아간다
        대기중이던 main메서드는 (println)을 호출한 이후부터 수행을 재개한다.

            │               │
            │               │
            │               │
            │      main     │
            └───────────────┘


    5. main메서드에도 더 이상 수행할 코드가 없으므로 종료되어,
        호출스택은 완전히 비워지게 되고 프로그램은 종료된다.

            │               │
            │               │
            │               │
            │               │
            └───────────────┘


    호출스택을 조사해보면 메서드간의 호출 관계와 현재 수행중인 메서드가 어느 것인지 알 수 있습니다.
    호출스택의 특징을 정리해보면 다음과 같습니다.

    - 호출스택을 조사해 보면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
    - 메서드가 수행을 마치고 나면 사용했던 메모리를 반환하고 스택에서 제거된다.
    - 호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이다.
    - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

    반환타입(return type)이 있는 메서드는 종료되면서 결과값을 자신을 호출한 메서드(caller)에게 반환한다.
    대기상태에 있던 호출한 메서드(caller)는 넘겨받은 반환값으로 수행을 계속 진행하게 됩니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<PrimitiveParameters(기본형 매개변수)>
    class Data { int x; }
public class Main {
    public static void main(String[] args) {
    /**
    <!--
        매개변수에는 기본형 매개변수와 참조형 매개변수가 있습니다

        기본형 매개변수
            변수의 값을 읽기만 할 수 있다.(read only)

         참조형 매개변수
            변수의 값을 읽고 변경할 수 있다. (read & wrtie)

        메서드의 매개변수를 기본형으로 선언하면 단순히 저장된 값만 얻지만,
        참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어오는 것은 물론 값을 변경하는 것도 가능하다.
    -->
    **/

        Data d = new Data(); // 인스턴스 d 생성
        d.x = 10;
        System.out.println("main() : x = " + d.x);

        change(d.x);

        /**
        <!--
            // 1. change 메서드가 실행되면서 'd.x(10)'가 change메서드의 매개변수 x에 복사됨

            │               │
            │    change     │
            │   x(10)       │  ◀───────┐
            ├───────────────│           │
            │     main      │           │
            │   d(0x100)    │  ───▶  x(10)
            └───────────────┘

            // 2. change 메서드에서 x의 값을 1000으로 변경

            │               │
            │    change     │
            │   x(1000)     │
            ├───────────────│
            │     main      │
            │   d(0x100)    │  ───▶  x(10)
            └───────────────┘

            // 3. change 메서드가 종료되면서 매개변수 x는 스택에서 제거됨

            ├───────────────│
            │     main      │
            │   d(0x100)    │  ───▶  x(10)
            └───────────────┘

            이 과정에서 중요한 것은 'd.x의 값이 변경된 것이 아니라. change메서드의 매개변수 x의 값이 변경된 것
            즉, 원본이 아닌 복사본이 변경된 것이라 원본에는 아무런 영향을 미치지 못합니다.
            이처럼 기본형 매개변수는 변수에 저장된 값만 읽을 수 있을 뿐 변경할 수는 없습니다.
        -->
        **/

    }
    static void change(int x){ // 기본형 매개변수
        x = 1000;
        System.out.println("chane() : x = " + x);
    }
}

───────────────────────────────────────────────────────────────────────────────────────────────
<ReferencedParameters(참조형 매개변수)>
    class Data2 { int x; }
    public class Main {
        public static void main(String[] args) {
            Data2 d = new Data2();
            d.x = 10;
            System.out.println("main() : x = " + d.x);
            change(d); /** 이 부분이 다릅니다. d.x => d **/
            System.out.println("After change(d)");
    
            System.out.println("main() : x = " + d.x);
        }
        static void change(Data2 d){
            d.x = 1000;
            System.out.println("change() : x = " + d.x);
        }
    }
    /**
    <!--
        이전과 달리 change메서드를 호출한 후에 d.x의 값이 변경되었습니다.
        1. change메서드가 호출되면서 참조변수 d의 값(주소)이 매개변수 d에 복사됨.
           이제 매개변수 d에 저장된 주소값으로 x에 접근이 가능해집니다.

             │ change        │
             │   d(0x100)    │
             ├────── ▲ ──────┤
             │       ↑       │
             │ main  │       │      0x100
             │   d(0x100)    │ ───▶ x(10)
             └───────────────┘

        2. change메서드에서 매개변수 d로 x의 값을 1000으로 변경.

             │ change        │
             │   d(0x100)    │ ───────┐
             ├───────────────┤        ↓
             │ main          │      0x100
             │   d(0x100)    │ ───▶ x(1000)
             └───────────────┘

        3. change메서드가 종료되면서 매개변수 d는 스택에서 제거됨.

             ┌───────────────┐
             │ main          │      0x100
             │   d(0x100)    │ ───▶ x(1000)
             └───────────────┘
        이전 예제와 달리 change메서드의 매개변수를 참조형으로 선언햇기 때문에
        x의 값이 아닌 변수 d의 주소가 매개변수 d에 복사되었습니다.
        이제 main메서드의 참조변수 d와 change메서드의 참조변수d는 같은 객체를 가리키게 됩니다.
        따라서 매개변수 d로 x의 값을 읽는 것과, 변경이 가능한 것입니다.
    -->
    **/
───────────────────────────────────────────────────────────────────────────────────────────────
<ReferencedParametersReturnType(참조형 반환타입)>
class Data3 { int x; }
public class Main {
    public static void main(String[] args) {
        Data3 d = new Data3();
        d.x = 10;
        Data3 d2 = copy(d);

        System.out.println("d.x = " + d.x);
        System.out.println("d.x = " + d2.x);
    }

    static Data3 copy(Data3 d){
        Data3 tmp = new Data3();
        tmp.x = d.x;
        return tmp;
    }
}

/**
<!--
    매개변수 뿐만이 아니라, 반환타입도 참조형이 될 수 있습니다.
    반환타입이 참조형이라는 것은, 반환하는 값의 타입이 참조형이라는 말입니다.
    모든 참조형 타입의 값은 '객체의 주소'입니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<static메서드와 instance메서드>
변수에서 그랬던 것과 같이, 메서드 앞에 static이 붙어 있으면 클래스 메서드이고,
붙어있지 않다면 인스턴스 메서드입니다.

클래스 메서드도 클래스 변수처럼, 객체를 생성하지 않고도 '클래스이름.메서드이름(매개변수)'와 같은 식으로 호출이 가능합니다.
반면에 인스턴스 메서드는 반드시 객체를 생성해야합니다.

<!--
    클래스에 변수명을 선언햇을때 static으로 선언하면
    인스턴스 선언없이 (클래스명.변수명)을 사용가능한 것과 같습니다.
-->

간단하게 설명하자면, 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는 메서드이며
따라서 인스턴스 메서드란 작업을 수행을 하는데 인스턴스 변수를 필요로 하는 메서드입니다.
그런데 인스턴스 변수는 인스턴스(객체)를 생성해야만 만들어지므로,
인스턴스메서드 역시 인스턴스를 생성해야만 호출할 수 있는것 입니다.

반면에 메서드중에는 인스턴스와 관계없는(인스턴스 변수나, 메서드를 사용하지 않는) 메서드를
클래스 메서드(static메서드)로 정의합니다.
───────────────────────────────────────────────────────────────────────────────────────────────
<StaticMethodInstanceMethod(스태틱 메서드와 인스턴스 메서드)>
/**
<!--
    클래스(static) 메서드는 인스턴스 생성 없이 호출가능하다.

    이번에는 같은 기능을 가진 더하기, 빼기, 곱하기, 나누기를
    인스턴스 메서드와 클래스 메서드로 하나씩 설정한 후 사용하는 것으로 알아보겠습니다.
-->
 **/
class MyMath2{
    long a, b;
    long add()      { return a + b; }
    long subtract() { return a - b; }
    long multiply() { return a * b; }
    double divide() { return a / b; }

    static long add(long a, long b){ // 더하기
        return a + b;
    }
    static long subStract(long a, long b){ // 빼기
        return a - b;
    }
    static long multiply(long a, long b){ // 곱하기
        return a * b;
    }
    static double divide(double a, double b){ // 나누기
        return a / (double)b;
    }
}
public class Main {
    public static void main(String[] args) {
        System.out.println(MyMath2.add(200, 100));
        System.out.println(MyMath2.subStract(200, 100));
        System.out.println(MyMath2.multiply(200, 100));
        System.out.println(MyMath2.divide(200, 100));

        MyMath2 mm = new MyMath2(); // 인스턴스를 생성
        mm.a = 200;
        mm.b = 100;
        System.out.println(mm.add());
        System.out.println(mm.subtract());
        System.out.println(mm.multiply());
        System.out.println(mm.divide());
    }
}

/**
<!--
    이와 같이 static으로 선언한 메서드는 클래스를 생성한순간 클래스명.메서드명으로 사용이 가능하지만
    인스턴스로 선언한 메서드는 인스턴스를 생성하기 전에는 사용할 수 없는것을 볼 수 있습니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<CallsMethods(메서드간의 호출)>
    

public class Main {
    static class TestClass1{
        void instanceMethod(){}      // 인스턴스 메서드
        static void staticMethod(){} // static메서드

        void instanceMethod2(){      // 인스턴스 메서드
            instanceMethod();        // 다른 인스턴스 메서드를 호출한다.
            staticMethod();          // 다른 statice메서드를 호출한다.
        }

        static void staticMethod2(){ // static메서드
            // instanceMethod();        // Error! 클래스 메서드는 인스턴스 메서드를 호출할 수 없다
            staticMethod();          // statice메서드는 호출할 수 있다.
        }
    }
/**
<!--
 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않더라도 서로 참조 또는 호출이 가능합니다.
 그러나, 클래스멤버가 인스턴스 멤버를 호출하는 경우에는 인스턴스를 생성해야합니다.

 그 이유는 인스턴스 멤버가 존재하는 시점에서 클래스 멤버는 항상 존재하지만,
 클래스 멤버가 존재한다고해서 인스턴스 멤버가 존재하지 않을 수도 있기 때문입니다.
-->
**/
/**============================================================**/


    // 이번에는 변수와 메서드간의 호출에 대해서 확인해봅시다.
    class TestClass2{
        int iv;         // 인스턴스 변수
        static int cv;  // 클래스 변수

        void instanceMethod(){      // 인스턴스메서드
            System.out.println(iv); // 인스턴스 변수를 사용할 수 있다
            System.out.println(cv); // 클래스 변수를 사용할 수 있다.
        }

        static void staticMethod(){ // static메서드
            // System.out.println(iv); // Error! 인스턴스 변수를 사용할 수 없다
            System.out.println(cv); // 클래스 변수를 사용할 수 있다.
        }
    }

    public static void main(String[] args) {
        TestClass2.staticMethod(); // 같은 Main 클래스 내의 static메서드는 사용이 가능합니다.

        // TestClass2.instanceMethod(); // 같은 클래스 내부라도 static 클래스 내부에서 다른 클래스의 인스턴스에 접근할 수 없습니다.
        // 접근방법
        Main mainInstance = new Main();
        TestClass2 aaa = mainInstance.new TestClass2();
        aaa.instanceMethod();
        /**
        <!--
            1. 먼저 기본이되는 Main 메서드를 생성합니다.
            2. Main 인스턴스 안의 TestClass2 클래스를 참조하는 aaa 인스턴스를 생성합니다.
            3. 생성한 인스턴스를 참조하여 메서드를 실행합니다.

            이러한 방법은 스태틱만 사용하는 방법에 비해 호출속도가 느리니
            복잡하지 않은 간단한 메서드는 static을 사용하는것을 권장합니다.
        -->
        **/

    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<OverLoading(오버로딩)>
/**
<!--
    메서드도 변수와 마찬가지로 같은 클래스 내에서 서로 구별될 수 있어야 합니다.

    그러나 자바에서는 한클래스 내에 이미 사용하려는 이름과 같은 메서드가 있더라도
    매개변수의 개수, 또는 타입이 다르면 같은 이름을 사용해서 메서드를 정의할 수 있습니다.

    이처럼, 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을
    메서드 오버로딩(Method OverLoading)이라고 합니다.

    오버로딩이 성립하기 위해서는 다음과 같은 조건을 만족해야 합니다.

        1. 메서드의 이름이 같아야 한다.
        2. 매개변수의 개수 또는 타입이 달라야 한다. (같다면 이미 있는 메서드라고 에러를 출력)
        3. 반환 타입은 관계 없다.
 
    ※ 부모클래스의 메서드를 자식클래스에서 재정의하는 Override개념과 혼동하지 않도록 주의
-->
**/
public class Main {
    public static void main(String[] args) {
        MyMath mm = new MyMath();
        System.out.println("mm.add(3, 3) 결과 : " + mm.add(3,3));
        System.out.println("mm.add(3L, 3) 결과 : " + mm.add(3L,3));
        System.out.println("mm.add(3, 3L) 결과 : " + mm.add(3,3L));
        System.out.println("mm.add(3L, 3L) 결과 : " + mm.add(3L,3L));

        int[] a = {100, 200, 300};
        System.out.println("mm.add(a) 결과 : " + mm.add(a));
    }
}
class MyMath{
    int add(int a, int b){
        System.out.print("int add(int a, int b) - ");
        return a + b;
    }

    long add(int a, long b){
        System.out.print("int add(int a, int b) - ");
        return a + b;
    }

    long add(long a, int b){
        System.out.print("long add(long a, int b) - ");
        return a + b;
    }

    long add(long a, long b){
        System.out.print("long add(long a, int b) - ");
        return a + b;
    }

    int add(int[] a){ // 배열의 모든 요소의 합을 결과로 돌려준다
        System.out.print("int adD(int[] a) - ");
        int result = 0;
        for(int i = 0; i < a.length; i++){
            result += a[i];
        }
        return result;

    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<DefaultConstructor(기본 생성자)>
/**
<!--
    모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 합니다.

    지금까지 생성자를 모르고 프로그래밍을 해왓지만 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는
    컴파일러가 제공하는 기본 생성자(Default Constructor) 덕분입니다.
 
    컴파일을 할 때 소스파일(~.java)의 클래스에 생성자가 하나도 정의되지 않을 경우
    컴파일러는 자동적으로 아래와 같은 내용의 기본 생성자를 추가하여 컴파일을 합니다.
 
        클래스이름(){} => 기본생성자
        Main(){}     => Main클래스의 기본 생성자
-->
**/

class Data_1{
    int value;
}
class Data_2{
    int value;

    Data_2(int x){ // 매개 변수가 있는 생성자
        value = x;
    }
}
public class Main {
    public static void main(String[] args) {
        Data_1 d1 = new Data_1();
        // Data_2 d2 = new Data_2(); // compile error 발생
        Data_2 d2 = new Data_2(10); // 에러 발생하지않음
    }
}
/**
<!--
    이 예제를 보면 Data_2 d2 = new Data_2();에서 오류가 생기는 이유는
    Data_2(int x){ // 매개 변수가 있는 생성자
       value = x;
    }
    이렇게 직접 생성자를 생성하기 전에는 컴파일러가 자동으로 Data_2(){}라는 생성자를 추가해 주었지만
    직접 생성한 후에는 생성자가 있으므로 자동으로 생성자가 추가되지 않았는데
    만든 생성자의 매개변수 int x요소를 넣어주지 않아 오류가 발생합니다.
    따라서 위의 경우처럼 직접 만든 생성자에 맞는 매개변수를 넣어줄경우 오류가 발생하지 않습니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<ConstructorsParameters(매개변수가 있는 생성자)>
class Car{
    String color;       // 색상
    String gearType;    // 변속기의 종류
    int door;           // 문의 개수

    Car(){}

    Car(String c, String g, int d){
        color = c;
        gearType = g;
        door = d;
    }
}
public class Main {
    public static void main(String[] args) {
        Car c1 = new Car();
        c1.color = "white";
        c1.gearType = "auto";
        c1.door = 4;

        Car c2 = new Car("white", "auto", 4);
        System.out.println(
                "c1의 color = " + c1.color + ", gearType = " + c1.gearType + ", door의 개수 = " + c1.door
        );
        System.out.println(
                "c1의 color = " + c2.color + ", gearType = " + c2.gearType + ", door의 개수 = " + c2.door
        );
    }
}
/**
<!--
    c1, c2 두개의 생성방식이 있지만
    c1보다 c2의 생성방식이 조금 더 간결하고 직관적으로 보이는걸 확인할 수 있습니다.
    
    여기서 만약 Car(){}의 코드를 없앤다면 
    Car(String c, String g, int d) 생성자가 있기때문에
    Car(){}라는 기본 생성자가 생성되지 않아
    Car c1 = new Car();의 인스턴스 생성이 불가능해집니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<ConstructorThis(생성자에서 다른 생성자 호출하기)>
/**
<!--
    생성자에서 다른 생성자를 호출할때의 규칙
    생성자의 이름으로 클래스명 대신 this를 사용한다.
    한 생성자에서 다른 생성자를 호출할 때는 반드시 첫줄에서만 호출이 가능하다.

    다른 생성자를 첫줄에서만 호출이 가능한 이유는
    생성자 내에서 초기화 작업도중 다른생성자를 호출하게 되면
    호출된 다른 생성자 내의 멤버변수 값을 초기화 할 수 있기 때문입니다.(사실잘모름)

    생성자를 호출할 때는 this(매개변수)가 들어가게 되는데
    클래스명이아닌 매개변수를 통해 그와 똑같은 생성자를 찾습니다.
-->
**/

class Car{
    String color;       // 색상
    String gearType;    // 변속기의 종류 auto(자동), manual(수동)
    int door;           // 문의 개수

    Car(){
        this("white", "auto", 4);
    }

    Car(String color){
        this(color, "auto", 4);
    }
    Car(String c, String g, int d){
        this.color = c;
        this.gearType = g;
        this.door = d;
    }
}
public class Main {
    public static void main(String[] args) {
        Car c1 = new Car();
        Car c2 = new Car("blue");
        System.out.println(
                "c1의 color = " + c1.color + ", gearType = " + c1.gearType + ", door의 개수 = " + c1.door
        );
        System.out.println(
                "c1의 color = " + c2.color + ", gearType = " + c2.gearType + ", door의 개수 = " + c2.door
        );
    }
}
/**
<!--
    이 방식은 마치 실생활에서 자동차(Car인스턴스)를 생성할 때, 아무런 옵션을 주지 않으면
    기본적으로 흰색(white), 자동변속기어(auto), 문의 개수(4개)인 자동차를 생산하는 것에 비유할 수 있습니다.
-->
 **/
───────────────────────────────────────────────────────────────────────────────────────────────
<VariablesReset(변수의 초기화)>
public class Main {
    static {
        System.out.println("static { }"); // 클래스 초기화 블럭
    }

    {
        System.out.println("{ }"); // 인스턴스 초기화 블럭
    }
    public Main(){
        System.out.println("생성자");
    }
    public static void main(String[] args) {
        System.out.println("Main bt = new Main(); ");
        Main bt = new Main();

        System.out.println("Main bt = new Main(); ");
        Main bt2 = new Main();
    }
}
/**
<!--

    예제가 실행되면서 Main이 메모리에 로딩될 때
    클래스 초기화 블럭이 가장 먼저 수행되어 static { }이 화면에 출력된다.
    그 다음에 main 메서드가 수행되어 Main의 인스턴스가 생성되면서
    인스턴스 초기화 블럭이 먼저 수행되고, 끝으로 생성자가 수행된다.
    
    이 결과에서 알 수 있듯이 클래스 초기화 블럭은 처음 메모리에 로딩될 때 한번만 수행되었지만,
    인스턴스 초기화블럭은 인스턴스가 생성될 때 마다 수행되었다.
-->
**/


/**<!--============================================================================ -->**/
class InitTest{
    int x;      // 인스턴스 변수
    int y = x;  // 인스턴스 변수

    void method(){
        int i;          // 지역변수
        // int i = 0;   // => 이렇게 초기화를 해서 값을 줄 시 아래에 에러가 사라집니다.
        // int j = i;   // 지역변수를 초기화 하지 않고 사용했기때문에 에러가 나타남
    }
}
/**
<!--
    변수를 선언하고 처음으로 값을 저장하는 것을 '변수의 초기화'라고 합니다.
    멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 되기에 그냥 사용해도 되지만
    지역변수는 자동으로 초기화가 이루어지지 않아 사용하기전 반드시 초기화를 해주어야 합니다.

    각 타입의 기본값(default value)은 다음과 같습니다

    boolean          => false
    char             => '\u0000'
    byte, short, int => 0
    long             => 0L
    float            => 0.0f
    double           => 0.0d 또는 0.0
    참조형            => null
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<Z-Test01-Instance>
/**
    <!-- 지금까지 배운 클래스, 함수 사용방법 실습해보기 -->
**/


public class Main {
    public static void main(String[] args) {
        Student s = new Student("홍길동", 1, 1, 100, 60, 76);
        String str = s.info();
        System.out.println(str);

        int total = s.getTotal();
        float average = s.getAverage();
        System.out.println("이름은 : " + s.name);
        System.out.println("총점은 : " + total);
        System.out.println("평균점수는 : " + average);

    }
}
class Student{
    String name;
    int ban;
    int no;
    int kor;
    int eng;
    int math;
    Student(String name, int ban, int no, int kor, int eng, int math){
        this.name = name;
        this.ban = ban;
        this.no = no;
        this.kor = kor;
        this.eng = eng;
        this.math = math;
    }
    String info(){
        return name + ", " + ban + ", " + no + ", " + kor + ", " + eng + ", " + math;
    }

    int getTotal(){
        return kor + eng + math;
    }

    float getAverage(){
        // return Math.round(((kor + eng + math)/(float)3)*100)/100f;
        float average = (kor + eng + math)/3f;
        average = Math.round(average * 100) / 100f;
        return average;
    }

}
───────────────────────────────────────────────────────────────────────────────────────────────
<Z-Test02-Distance1>
    public class Main {
        // 거리구하기
        // 두 점(x, y)와 (x1, y1) 간의 거리를 구한다.
        static double getDistance(int x, int y, int x1, int y1) {
            int dx = x1 - x;
            int dy = y1 - y;
            return Math.sqrt(dx * dx + dy * dy);
        }
    
        public static void main(String[] args) {
            System.out.println(getDistance(1, 1, 2, 2));
        }
    }
───────────────────────────────────────────────────────────────────────────────────────────────
<Z-Test02-Distance2>
class MyPoint{

    int x;
    int y;

    MyPoint(int x, int y){
        this.x = x;
        this.y = y;
    }

    double getDistance(int x1, int y1){
        int dx = x1 - x;
        int dy = y1 - y;
        return Math.sqrt(dx * dx + dy * dy);
    }

}
public class Main {

    // 거리 구하기
    // 두 점(x, y)와 (x1, y1) 간의 거리를 구한다.

    public static void main(String[] args) {
        MyPoint p = new MyPoint(1, 1);
        // p와 (2,2)의 거리를 구한다
        System.out.println(p.getDistance(2, 2));
    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<Extends(상속 - inheritance)>
// 상속 예제
class TV{
    boolean power; // 전원상태(on/off)
    int channel;   // 채널

    void power(){
        power = !power;
    }
    void channelUp(){
        ++channel;
    }
    void channelDown(){
        --channel;
    }
}
class SmartTv extends TV{ // 상속
    boolean caption; // 캡션상태(on/off)
    void displayCaption(String text){
        if(caption){ // 캡션상태가 on(true)일 때만 text를 보여준다.
            System.out.println(text);
        }
    }
}
public class Main {
    public static void main(String[] args) {
        SmartTv stv = new SmartTv();
        stv.channel = 10;
        stv.channelUp();
        System.out.println(stv.channel);
        stv.displayCaption("Hello World");
        stv.caption = true;
        stv.displayCaption("Hello World");
    }
}

// 이 코드는 caption값이 true가되야 displayCaption의 sout이 작동하는 코드입니다.

<!--
/**
상속(Inheritance)이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것입니다.

상속해주는 클래스를 '조상(부모) 클래스'라고 하며, 상속 받는 클래스를 '자손(자식) 클래스'라고 합니다.

자식 클래스에 새로운 변경사항이 추가되어도, 조상 클래스는 아무런 영향을 받지 않습니다.

그러나 조상 클래스가 변경될 경우 자식클 래스는 조상 클래스의 모든 멤버를 상속받으므로,

항상 조상 클래스보다 같거나 많은 멤버를 가집니다.

따라서 상속을 받는다는 것은 조상 클래스를 확장(extends)한다는 의미로 해석할 수 있고

이것이 상속에 사용되는 키워드가 extends인 이유입니다.
**/
-->
───────────────────────────────────────────────────────────────────────────────────────────────
<단일상속(single inheritance)>
    
    자바에서는 단일 상속만을 허용합니다.
    
    예를들어 TvDvd 클래스가 있고, 이는 TV클래스와 DVD클래스에서 동시에 상속받는다고 가정해봅시다.
    
    두 클래스 모두 power()라는 메서드가 존재한다면 충돌이 일어나게 됩니다.
    
    이러한 문제점을 제거하고자 자바에서는 다중상속자체를 포기하고 단일상속만을 허용합니다.
───────────────────────────────────────────────────────────────────────────────────────────────
<Overriding(오버라이딩)>
/**
<!--
    Overide : 재정의
    조상클래스로부터 상속받은 메서드의 내용을 변경하는것을 오버라이딩이라고 합니다.
    상속받은 그대로 메서드를 사용하는 경우도 하지만, 자손클래스에서 자신에 맞게 변경해야될 때가 있습니다.
    이때 메서드를 변경하는것을 오버라이딩이라고합니다.
 
    오버로딩과 비슷하게 보이지만 다른 개념이므로 단어 혼동에 주의

    오버라이딩의 조건

        1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.

            접근 제어자의 접근범위를 넓은것에서 좁은 것 순으로 나열하면
            public -> proected -> (default) -> private 순으로 정렬됩니다.

        2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

            class Parent {
                void parentMethod() throws IOException, SQLException{
                    ...
                }
            }
            class Child extends Parent{
                void parentMethod() throws IOException{
                    ...
                }
            }
            이와 같이 조상클래스보다 같거나 적은수의 예외를 선언할 수 있습니다.

        3. 선언부가 조상 클래스의 메서드와 일치해야 한다.(너무 당연한것)
-->
**/
class Point{
    int x;
    int y;
    String getLocation() {
        return "x : " + x + ", y : "+ y;
    }
}

class  Point3D extends Point{
    int z;
    String getLocation(){
        return "x : " + x + ", y : " + y + ", z : " + z;
    }
}
public class Main {
    public static void main(String[] args) {
        Point3D aaa = new Point3D();
        aaa.x = 1;
        aaa.y = 1;
        aaa.z = 1;
        System.out.println(aaa.getLocation());
    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<Super(참조변수)>
/**
    super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수입니다.

**/
class Parent1{
    int x = 10;
}
class Child1 extends  Parent1{
    int x = 20;

    void method(){
        System.out.println("x = " + x);
        System.out.println("this.x = " + this.x);
        System.out.println("super.x = " + super.x);
    }
}
public class Main {
    public static void main(String[] args) {
        Child1 a = new Child1();
        a.method();
        /**
            x = 20
            this.x = 20     => 자식의 x
            super.x = 10    => 조상의 x

            이와 같이 자식과 조상이 같은 x값을 가지고 있을때, super를 사용하면 구분할 수 있습니다.

            만약 Child1에 x변수가 없다면 this.x나 super.x둘다 Parent1의 x를 따라갑니다.
        **/

        Point3D b = new Point3D(1, 2, 3);
        System.out.println("x = " + b.x + ", y = " + b.y + ", z = " + b.z);

    }
}



class Point{
    int x, y;
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}

class Point3D extends Point{
    int z;
    Point3D(int x, int y, int z){
        super(x, y); // Point(int x, int y)를 호출
        this.z = z;
    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<Package(패키지)>
<!-- Main.java -->
import com.codechobo.book.chobo;
/**
<!--
패키지란 클래스의 묶음입니다.

    패키지에는 클래스 또는 인터페이스를 포함시킬 수 있으며,
    서로 관련된 클래스들 끼리 그룹단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있습니다

    지금까지는 클래스 이름으로만 클래스를 구분했지만, 사실 클래스의 실제 이름은 패키지명을 포함한 것입니다.

    예를 들면

    String의 실제 클래스 이름은 java.lang.String입니다.
    java.lang패키지에 속한 String클래스라는 의미입니다.
    따라서 같은 이름의 클래스일지라도 서로 다른 패키지에 속하면 패키지명으로 구별이 가능합니다.

    클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리(폴더)입니다.

    디렉토리(폴더)가 하위의 디렉토리를 가질 수 있는 것처럼
    패키지도 다른 패키지를 포함할 수 있으며 .으로 구분합니다

    ex)java.lang
    lang 패키지는 java 패키지의 하위 패키지입니다.
-->
**/
public class Main {
    public static void main(String[] args) {
        chobo a = new chobo();
        a.aaa(); // chobo 클래스의 aaa 함수 호출
    }

}


<!-- =========================================================== -->

<!-- com폴더 -> codechobo폴더 -> book폴더 -> chobo.java -->
package com.codechobo.book;

public class chobo { // public을 설정해주지 않으면 Main에서 사용불가능함
    public void aaa(){
        System.out.println("Hello world!");
    }
}

───────────────────────────────────────────────────────────────────────────────────────────────
<Import>
/**
<!--
    코드를 작성할 때 다른 패키지의 클래스를 사용하려면 클래스 이름을 사용해야 합니다.
    하지만 매번 패키지명을 붙여서 사용하기는 불편합니다.
    이때 클래스 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시할 수 있습니다.

    import문 선언 방법

        import 패키지명.클래스명;
        import 패키지명.*;
-->
**/
// import
import java.util.Date; // import문을 사용해서 패키지명을 생략할 수 있습니다.

// static import
import static java.lang.Integer.*;      // Integer클래스의 모든 static 메서드

public class Main {
    public static void main(String[] args) {
// import
    // java.util.Date today = new java.util.Date(); // => 너무길다
    Date today = new Date();
    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<StaticImport>
/**
<!--
    import문을 사용해서 클래스의 패키지명을 생략이 가능한것과 같이
    static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있습니다.
    특정 클래스의 static 멤버를 자주사용할 때 편리하고, 코드도 간결해집니다.
-->
**/
import static java.lang.Math.random;    // Math.random()만
import static java.lang.Math.*;         // 위의 Integer와 독같이 Math클래스의 모든 static 메서드를 뜻합니다.
import static java.lang.System.out;     // System.out을 out만으로 참조 가능

public class Main {
    public static void main(String[] args) {
// static import
    // System.out.println(Math.random()); => System.out을 줄입니다.
    out.println(random());

    // System.out.println("Math.PI :" + Math.PI); => Math를 줄입니다.
    out.println("Math.PI :" + PI);
    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<제어자(Modifier)>
/**
<!--
    제어자(Modefier)는 클래스, 변수 또는 메서드와 선언부와 함께 사용되어 추가적인 의미를 부여합니다.
    제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있습니다

        접근 제어자 : public, protected, (default), private
        그     외  : static, final, abstract, native, tranient, synchronized, volatile, strictfp

        제어자는 클래스나 멤버변수, 메서드에 주로 사용되며,
        하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능합니다.
        그러나, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 없습니다.

        즉, 하나의 대상에 대해서 public과 private를 함께 사용할 수 없습니다.
-->
**/

public class Main {
    public static void main(String[] args) {


    }
/**
<!--
 static - 클래스의, 공통적인

 인스턴스 변수는 하나의 클래스로 부터 생성되었더라도, 각기 다른 값을 유지하지만,
 클래스 변수(static변수)는 인스턴스에 관계없이 같은 값을 가집니다.
 그 이유는 하나의 변수를 모든 인스턴스가 공유하기 때문입니다.
 static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스와 관계됬기 때문에
 인스턴스를 생성하지 않더라도 사욯알 수 있습니다.

     즉, 인스턴스 메서드와 static 메서드의 근본적인 차이는
     메서드내에서 인스턴스 멤버를 사용하는가, 사용하지 않는가 여부에 있다.
-->
 **/
    class StaticTest{
        static int width = 200;
        static int height = 120;
        static { /** 클래스 초기화 블럭 **/
            // static변수의 복잡한 초기화 수행
        }
        static int max(int a, int b){
            return a > b ? a: b;
        }
    }
/**
<!--
 final - 마지막의, 변경될 수 없는

 final은 '마지막의'또는 '변경될 수 없는'의 의미를 가지고 있고, 거의 모든 대상에 사용될 수 있습니다.

    변수에 사용하면 값을 변경할 수 없는 상수가 되고
    메서드에 사용되면 오버라이딩을 할 수 없게되고
    클래스에 사용되면 상속(extends)이 불가능해집니다.

    자바스크립트의 const개념과 유사합니다.
-->
**/
    final class FinalTest{              // 조상이 될 수 없는 클래스(상속불가)
        final int MAX_SIZE = 10;        // 값을 변경할 수 없는 멤버변수(상수)
        final int getMaxSize(){         // 오버라이딩할 수 없는 메서드(변경불가)
            final int LV = MAX_SIZE;    // 값을 변경할 수 없는 지역변수(상수)
            return MAX_SIZE;
        }
    }
/**
 abstarct - 추상의, 미완성의\

 메서드의 선언문만 작성하고 실제 수행내용은 구현하지 않는 추상 메서드를 선언하는데 사용됩니다.
 클래스에 사용되어 클래스 내에 추상 메서드가 존재한다는 것을 쉽게 알 수 있게 합니다.
**/
    a  abstract void move();           // 추상클래스(구현부가 없는 메서드)
    }bstract class AbstractTest{        // 추상 클래스(추상 메서드를 포함한 클래스)
      
/**
<!--
     * 추상 클래스는 아직 완성되지 않은 메서드가 존재하는
     * '미완성 클래스'이므로 인스턴스를 생성할 수 없습니다.

        AbstractTest a = new AbstractTest() => 인스턴스 생성이 불가능합니다.
-->
**/
}
───────────────────────────────────────────────────────────────────────────────────────────────
<접근 제어자(AccessModifier)>

접근 제어자는 멤버 또는 클래스에 사용되어,
해당하는 멤버나 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 합니다.

    접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지는 않습니다.
    접근 제어자가 지정되어 있지 않다면, 그것은 접근제어자가 default임을 뜻합니다.

접근 제어자가 사용될 수 있는곳 : 클래스, 멤버변수, 메서드, 생성자

    (default)   : 같은 패키지 내에서만 접근이 가능하다
    private     : 같은 클래스 내에서만 접근이 가능하다.
    protected   : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
    public      :   접근 제한이 전혀 없다

접근 제한이 넓은 순에서 좁은 순으로 왼쪽부터 나열하면 다음과 같습니다

    public   >  protected       >   default     >   private
접근제한없음  |  같은패키지+자손  |   같은패키지   |  같은 클래스
───────────────────────────────────────────────────────────────────────────────────────────────
<캡슐화(Encapsulation)와 접근 제어자(AccessModifier)>
<EncapsulationAccessModifier>
/**
<!--
 클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는,
 클래스의 내부에 선언된 데이터를 보호하기 위함입니다.
 데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요합니다.

 이것을 데이터 감추기(data hiding)이라고 하며, 객체지향개념의 캡슐화(Encapsulation)에 해당하는 내용입니다.
 
 또 다른 이유는 클래스 내에서만 사용되는
 내부 작업을 위해 임시로 사용되는 멤버변수나
 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감추기 위해서입니다.
 
 외부에서 접근할 필요가 없는 멤버들을 private로 지정하여 외부에 노출하지 않음으로써 복잡성을 줄일 수 있습니다.
 이것 역시 캡슐화에 해당합니다.
 
 접근 제어자를 사용하는 이유
 
    외부로부터 데이터를 보호하기 위해서
    외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서
 
    getter / setter 단축키
    private int hour;
    private int minute;
    private int second;

    이렇게 변수를 선언한 후
    코딩할 부분에 커서를 놓고 Alt + Insert키를 누르면 됩니다.
-->
**/

public class Main {
    public static void main(String[] args) {

    }

    public class Time{
        private int hour;
        private int minute;
        private int second;

        public int getHour() {
            return hour;
        }
        public void setHour(int hour) {
            if(hour < 0 || hour > 23) return;
            this.hour = hour;
        }

        public int getMinute() {
            return minute;
        }
        public void setMinute(int minute) {
            if(minute < 0 || minute > 59){
                return;
            }
            this.minute = minute;
        }

        public int getSecond() {
            return second;
        }
        public void setSecond(int second) {
            if(minute < 0 || minute > 59) return;
            this.second = second;
        }
    }
    /**
    <!--
     get으로 시작하는 메서드(getter)는 단순히 멤버변수의 값을 반환하는 일을 하고,
     set으로 시작하는 메서드(setter)는 매개변수에 지정된 값을 검사하여
     조건에 맞는 값일 때만 멤버변수의 값을 변경하도록 작성되었습니다.
     
     만약 상속을 통해 확장이 예상되는 클래스라면 멤버에 접근 제한을 주되,
     자손클래스에서 접근하는 것이 가능하도록 private대신 protected를 사용합니다.
     private가 붙은 멤버는 자손 클래스에서도 접근이 불가능하기 때문입니다.
    -->
    **/
}

───────────────────────────────────────────────────────────────────────────────────────────────
<다형성(Polymorphism)>
/**
<!--
 다형성(polymorphism)
    다형성이란 '한 요소가 여러 가지 형태나 타입을 가질 수 있는 능력'을 의미합니다.
    자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였습니다.

    이는 조상 클래스 타입의 참조변수로, 자손클래스의 인스턴스를 참조할 수 있도록 했다는 말입니다.

    TV와 SmartTV 클래스를 통해 알아봅시다.
-->
**/

class Tv{
    boolean power;
    int channel;
    void power()        { power = !power; }
    void channelUp()    { ++channel; };
    void channelDown()  { --channel; }
}

class SmartTv extends Tv{
    String text;
    void caption(){}
}

public class Main {
    public static void main(String[] args) {
    /**
    <!--
     Tv t = new Tv();
     SmartTv s = new SmartTv;
     => 참조변수 타입 변수명 = new 인스턴스타입
     이처럼 인스턴스의 타입과, 참조변수 타입이 일치하는 것이 보통이지만
     Tv와 SmartTv가 서로 상속관계에 있을경우
     다음과 같이 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능합니다.
    -->
    **/

        Tv      t = new SmartTv(); // 조상 클래스 타입 참조변수로 자손 타입 인스턴스 참조
        SmartTv s = new SmartTv(); // 참조변수와 인스턴스의 타입이 일치

        /**
        <!--
         둘 다 같은 타입의 인스턴스를 생성했지만, 참조변수의 타입에 따라 사용할 수 잇는 멤버변수의 개수가 달라집니다.

         Tv타입의 참조변수 't'로는 SmartTv인스턴스 중에서 Tv클래스의 멤버들(상속받은 멤버포함)만 사용할 수 있습니다.
             따라서 생성된 't'는 SmartTv의 멤버 중에서
             Tv클래스에 정의되지 않은 멤버 text와 caption()은 사용할 수 없습니다.
        -->
        **/


        /**
        <!--
         반대로 자손타입의 참조변수로 조상타입의 인스턴스를 사용할 수 있을까?
         // SmartTv c = new Tv();
         정답은 불가능합니다. 이유는 인스턴스로 사용된 Tv의 멤버 개수보다
         SmartTv의 'c'가 사용할 수 있는 멤버개수가 더 많기 때문입니다.

         이런 이유로 자바에서는 자손 타입의 참조변수로 조상 타입의 인스턴스를 생성하는 것을 허용하지 않습니다.
        -->
        **/
    }

}
───────────────────────────────────────────────────────────────────────────────────────────────
248
───────────────────────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────────────────────