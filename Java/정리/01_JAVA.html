코드부분은 보기 어렵다면 인텔리제이로 실행해서 보는것을 권장

───────────────────────────────────────────────────────────────────────────────────────────────

<변수의 타입>

    <숫자>
        int / long
            정수(integer)를 저장하기 위한 타입(20억이 넘을 땐 long)
        
        float / double
            (floating-point number)를 저장하기 위한 타입(float는 오차없이 7자리, double은 15자리)
    <문자>
        char
            문자(character)를 지정하기 위한 타입
            
        String
            여러 문자(문자열, string)를 저장하기 위한 타입
───────────────────────────────────────────────────────────────────────────────────────────────
<지시자>
public class Main {
    public static void main(String[] args){
        System.out.printf("Age:%d", 14);
        <!-- // System.out.println("Age:%d", 14); <= println은 불가능 -->
        
        <!-- %d를 사용하여 변수의 값을 지정된 형식으로 변환해서 사용가능하다, -->
        <!-- 이때 출력될 값과 지시자의 순서는 일치해야 한다. -->
    }
}

<지시자의 종류>
    %d
        10진(decimal) 정수의 형식으로 출력
    %x
        16진(hexa-decimal) 정수의 형식으로 출력
    %f
        부동 소수점(floating- point)의 형식으로 출력
    %c
        문자(character)로 출력
    %s
        문자열(string)로 출력

        더 많은 지시자는 검색으로 알아볼것
───────────────────────────────────────────────────────────────────────────────────────────────
<Scanner>
    import java.util.Scanner;
    // 스캐너 클래스를 사용하기 위해 추가

    public class Main {
        public static void main(String[] args) {

            Scanner scanner = new Scanner(System.in);
            System.out.print("두자리 정수를 하나 입력해주세요");
            String input = scanner.nextLine();
            int num = Integer.parseInt(input);
            System.out.println("입력내용 : " + input);
            System.out.printf("num = %d%n", num);

    //      형변환을 하지 않고 그대로 숫자받기
            Scanner scanner2 = new Scanner(System.in);
            System.out.print("두자리 정수를 하나 입력해주세요 ");
            Integer input2 = scanner2.nextInt(); // 바로 int형으로 받기
            System.out.println("입력내용 : " + input2);
            System.out.printf("num = %d%n", input2);
        }
    }
    
<!-- nextInt()나 nextFloat()으로 바로 숫자를 입력받을 수 있습니다 -->
───────────────────────────────────────────────────────────────────────────────────────────────
<if문>
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        int score = 0; // 학점을 저장하기 위한 변수
        char grade = ' '; // 학점을 저장하기 위한 변수, 공백으로 초기화 된다.
        System.out.print("학점을 입력하세요");
        Scanner scanner = new Scanner(System.in);
        score = scanner.nextInt(); // 화면을 통해 입력받은 숫자를 score에 저장
        if(score >= 90){ // score가 90점보다 같거나 크면 A학점
            grade = 'A';
        }else if(score >= 80){ // score가 80점 보다 같거나 크면 B학점
            grade = 'B'; 
        }else if(score >= 70){ // score가 70점보다 같거나 크면 C학점
            grade = 'C';
        }else{ // 나머지는 D학점
            grade = 'D';
        }
        System.out.println("당신의 학점은 " + grade + "입니다");
    }

}
───────────────────────────────────────────────────────────────────────────────────────────────
<switch문>
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        System.out.print("현재 월을 입력하세요");

        Scanner scanner = new Scanner(System.in);
        int month = scanner.nextInt();

        switch(month){
            case 3: 
            case 4: 
            case 5:
                System.out.println("현재 계절은 봄입니다.");
                break;
            case 6: case 7: case 8:
                System.out.println("현재 계절은 여름입니다.");
                break;
            case 9: case 10: case 11:
                System.out.println("현재 계절은 가을입니다.");
                break;
            case 12: case 1: case 2:
                System.out.println("현재 계절은 겨울입니다.");
                break;
        }

    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<for문>
public class Main {
    public static void main(String[] args) {
        System.out.println("***********");
        // ***********

        System.out.println("====================");

        for(var i = 0; i <= 10; i++){
            System.out.print("*");
        }
        // ***********

        System.out.println("\n====================");

        System.out.println("시작");
        for(var i = 1; i <= 5; i++){
            for(var j = 1; j <= i; j++) {
                System.out.print("*");
            }
            System.out.println();
        }
        // *
        // **
        // ***
        // ****
        // *****
    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<while문>
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // while(조건식){
        //     실행할코드
        // }
        int num = 0, sum = 0;
        System.out.println("숫자를 입력하세요(예:12345)");
        Scanner scanner = new Scanner(System.in);
        String tmp = scanner.nextLine();
        num = Integer.parseInt(tmp);
        while(num != 0){
            // num을 10으로 나눈 나머지를 sum에 더함
            sum += num % 10;
            System.out.printf("sum=%d num=%d\n", sum, num);
            num /= 10; // int형이기 때문에 0.1이되면 0을 반환함
        }

        // do-while문
        // ~의 결과가 조건식을 벗어날때까지 반복
        // 결과를 먼저 내고 조건식에 맞추기때문에 최소한 한번의 실행을 보장함

        int input = 0, answer = 0;
        answer = (int)(Math.random() * 100) + 1; // 1과 100사이의 임의의 숫자
        do{
            System.out.println("1과 100사이의 정수를 입력하세요");
            input = scanner.nextInt();

            if(input > answer){
                System.out.println(answer);
                System.out.println("더 적은 수로 다시 시도해보세요");
            }else if(input < answer){
                System.out.println(answer);
                System.out.println("더 큰수로 다시 시도해보세요");
            }
        }while(input != answer); // input과 answer값이 같아지면 반복문 종료

    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<Array>
import java.util.Arrays;

public class Main {
    public static void main(String[] args){

        int[] Arr1 = new int[10];
        int[] Arr2 = new int[10];
        // int[] Arr3 = new int[]{100, 95, 80, 70, 5};
        int[] Arr3 = {100, 95, 80, 70, 5};
        char[] chArr = {'a', 'b', 'c', 'd'};

        for(int i=0; i < Arr1.length; i++){
            Arr1[i] = i + 1; // 1~10의 숫자를 차례대로 배열에 넣는다.
        }
        for(int i = 0; i < Arr2.length; i++){
            Arr2[i] = (int)(Math.random() * 10) + 1; // 1 ~10의 값을 배열에 저장
        }

        // 배열에 저장된 값들을 출력
        for(int i = 0; i < Arr1.length; i++){
            System.out.println(Arr1[i]+",");
        }
        System.out.println();

        System.out.println(Arrays.toString(Arr2));
        System.out.println(Arrays.toString(Arr3));
        System.out.println(Arrays.toString(chArr));
        System.out.println(Arr3);
        System.out.println(chArr);

        // [2, 2, 10, 9, 4, 9, 5, 2, 3, 9]
        // [100, 95, 80, 70, 5]
        // [a, b, c, d]
        // [I@6d03e736
        // abcd

        System.out.println("============");

        // 최대값과 최소값
        int[] score = {79, 88, 91, 33, 100, 55, 95};

        int min = score[0];
        int max = score[0];

        for(int i = 1; i < score.length; i++){
            if(score[i] > max){
                max = score[i];
                System.out.println(score[i]);
            }else if(score[i] < min){
                min = score[i];
                System.out.println(score[i]);
            }
        }
        System.out.println("최대값 : " + max);
        System.out.println("최소값 : " + min);

        // 랜덤 로또번호 만들기;
        int[] ball = new int[45]; // 1 ~ 45의 정수값을 저장할배열생성

        // 생성한 배열에 1-45 숫자 담기
        for(int i = 0; i< ball.length; i++){
            ball[i] = i+1;
        }

        System.out.println("============");

        // 값 두개를 변경할때 사용할 임시 변수
        int temp = 0;
        int j = 0;


        for(int i = 0; i < 6; i++){
            j = (int)(Math.random() * 45); // 0 ~ 44 범위의 임의의 값을 얻는다
            temp = ball[i]; // 임시변수는 ball[i]다
            ball[i] = ball[j]; // ball[i]는 ball[j]다
            ball[j] = temp; // 랜덤수는 temp가되고 다시 반복문으로 돌아가서 랜덤수 = ball[i]가 된다
        }

        // 배열 ball의 앞에서부터 6개의 요소를 출력
        for(int i = 0; i < 6; i++){
            System.out.printf("ball[%d] = %d\n", i, ball[i]);
        }
    }
}
        <!--
        이 코드를 풀어서 설명하기
        앞의 숫자 6가지가 [12, 15, 11, 40, 46, 97]이라고 했을때
        1.
           임시변수(0)는 0번 배열이다이다,
           0번 배열은 12다
           12는 임시변수다.
        2.
           임시변수(12)는 1번 배열이다
           1번 배열은 15다
           15는 임시변수다
        3.
           임시변수(15)는 2번 배열이다
           2번 배열은 11이다
           11은 임시변수다.
        ...
        -->

        <!-- 이런식으로 하여금 앞자리 6개를 랜덤한 1~45의 숫자로 출력할 수 있습니다. -->


        <!-- ※ 별로 효율적인 방법은 아닌거같음 -->
        <!-- 7번째 반복이 이루어지지 않으면 6번째 숫자가 랜덤이 아닌점도 맘에 안듬    -->
        
        // System.out.println("============");
        // for(i = 0; i < 6; i++){
        //  System.out.println("ball["+i+"] = " + (int)((Math.random() * 45)+1));
        // }
            



───────────────────────────────────────────────────────────────────────────────────────────────
<String Array>
public class Main {
    public static void main(String[] args) {
        String[] name1 = new String[3];
        name1[0] = "Kim";
        name1[1] = "Park";
        name1[2] = "Yi";

        String[] name2 = new String[] {"Kim", "Park", "Yi"};
        String[] name3 = {"Kim", "Park", "Yi"};

        <!-- 원래 클래스는 new 연산자를 통해 객체를 생성해야하지만 -->
        <!-- String은 특별히 생략이 가능함 -->

        <!-- => 원래는 이런 방식으로 생성해야 합니다. -->
        String[] name4 = new String[3];
        name4[0] = new String("Kim");
        name4[1] = new String("Park");
        name4[2] = new String("Yi");


    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<2차원 배열>
public class Main {
    public static void main(String[] args) {
        int[][] score = {
                { 100, 100, 100},
                { 20, 20, 20 },
                { 30, 30, 30 },
                { 40, 40, 40 },
                { 50, 50, 50 }
        };

        int korTotal = 0, engTotal = 0, mathTotal = 0;

        System.out.println("번호 국어 영어 수학 총점 평균");
        System.out.println("=========================");

        for(int i=0; i < score.length; i++){
            int sum = 0;
            float avg = 0;

            korTotal += score[i][0];
            engTotal += score[i][1];
            mathTotal += score[i][2];
            System.out.printf("%2d", i+1);

            for(int j=0; j < score[i].length; j++){
                sum += score[i][j];
                System.out.printf("%5d", score[i][j]);
            }

            avg = sum/(float)score[i].length;
            System.out.printf("%5d %5.1f\n", sum, avg);
        }
        System.out.println("=========================");
        System.out.printf("총점 : 국어 %3d 영어 %3d 수학 %3d\n", korTotal, engTotal, mathTotal);


        <!--
        1  100  100  100  300 100.0
        2   20   20   20   60  20.0
        3   30   30   30   90  30.0
        4   40   40   40  120  40.0
        5   50   50   50  150  50.0
       =========================
       총점 : 국어 240 영어 240 수학 240
        -->



    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<객체지향 언어>
    1. 코드의 재사용성이 높다.
        새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.

    2. 코드의 관리가 용이하다.
        코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.

    3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
        제어자와 메서드를 이용하여 데이터를 보호하고 올바른 값을 유지하도록 하며,
        코드의 중복을 제거하여 코드불일치로 인한 오동작을 방지한다.

    앞으로 객체지향개념을 배울때
        코드의 재사용성
        유지보수
        중복된 코드의 제거

    이 세가지를 중점적으로 보면 보다 쉽게 이해할 수 있다.
───────────────────────────────────────────────────────────────────────────────────────────────
<클래스(Class)와 객체(Object)>
<!-- ObjectAndClass1 -->

 public class Main {
    public static void main(String[] args) {

// 2. 인스턴스를 생성
        Tv t;             // Tv 객체를 참조하기 위한 변수 t 선언
        t = new Tv();     // Tv인스턴스를 생성한다.

// 3. 사용
        t.channel = 7;    // Tv인스턴스의 멤버변수 channel의 값을 7로 한다.
        t.channelDown();  // Tv인스턴스의 메서드 channelDown()을 호출한다.
        System.out.println("현재 채널은" + t.channel + " 입니다.");

// 4. 멤버변수 직접 수정
        t.channel = 111;
        System.out.println("t의 channel값을 111로 변경하였습니다.");

    }
}

// 1. Tv 클래스를 선언한다
class Tv{

    // Tv의 속성(멤버변수)
    String color;       // 색상
    boolean power;      // 전원상태(on/off)
    int channel;        // 채널

    // Tv의 기능(메서드)
    void power() { power = !power; }    // Tv를 켜거나 끄는 기능을 하는 메서드
    void channelUp() { ++channel; }     // Tv의 채널을 높이는 기능을 하는 메서드
    void channelDown() { --channel; }   // Tv의 채널을 낮추는 기능을 하는 메서드
}

/**
<!--

    이 예제는 TV클래스로부터 인스턴스를 생성하고, 인스턴스의 속성과 메서드를 사용하는 방법을 보여줍니다.

    Tv t;
    Tv클래스 타입의 참조변수 t를 선언합니다.
    메모리에 참조변수 t를 위한 공간이 마련됩니다.
    아직 인스턴스가 생성되지 않았으므로, 이 참조변수로 할수 있는것은 아무것도 없습니다

    t = new Tv();
    연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성된다.
    주소가 0x100인 곳에 생성되었다고 가정한다면, 이 때 멤버변수는 각 자료형에 해당하는 기본값으로 초기화된다.
    color는 참조형이므로 null,
    power는 boolean이므로 false,
    channel은 int이므로 0으로 초기화된다.

    t.channel = 7;
    참조변수 t에 저장된 주소에 있는 인스턴스의 멤버변수 channel에 7을 저장한다.
    여기서 알 수 있는것처럼, 인스턴스의 멤버변수(속성)를 사용하려면 '참조변수.멤버변수'와 같이 사용할 수 있다.

    t.channelDown();
    참조변수 t가 참조하고 있는 Tv인스턴스의 channelDown메서드를 호출하여
    멤버변수 channel에 저장되어있는 값을 1 감소시킨다.
 -->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<Class - 데이터와 함수>
클래스는 '객체를 생성하기 위한 틀'이며 클래스느 '속성과 기능'으로 정의되어있습니다.
이것은 객체지향의 관점에서 내린 정의이고, 이번엔 프로그래밍적인 관점에서 클래스의 정의를 알아봅시다.

    1. 변수
        하나의 데이터를 저장할 수 있는 공간

    2. 배열
        같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간

    3. 구조체(structure)
        서로관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간

    4. 클래스
        데이터와 함수의 결합(구조체 + 함수)


하나의 데이터를 저장하기 위해 변수를

그리고 같은 종류의 데이터를 보다 효율적으로 다루기 위해서 배열이라는 개념을 도입햇으며

후에는 구조체(structure)가 등장하여

자료형의 종류에 상관없이 서로 관계가 깊은 변수들을 하나로 묶어서 다룰 수 있도록 했습니다.


그동안은 데이터와 함수가 서로 관계가 없는 것처럼

데이터는 데이터끼리, 함수는 함수끼리 따로 다루어져 왔지만,

사실 함수는 주로 데이터를 가지고 작업을 하기 때문에 데이터와 함수는 관계가 깊습니다.



그래서 자바와 같은 객체지향언어에서는 변수(데이터)와 함수를 하나의 클래스에 정의하여

서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있게 했습니다.


이렇게 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이 클래스입니다.

<!-- 중요한 부분? -->
C언어에서는 문자열을 문자의 배열로 다루지만, 자바에서는 String이라는 클래스로 문자열을 다룹니다.
문자열을 단순한 문자의 배열로 정의하지 않고 클래스로 정의한 이유는
문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서입니다.
───────────────────────────────────────────────────────────────────────────────────────────────
<Private>
    public class Main {
        private int hour;
        private int minute;
        private float second;

        public void setHour(int h){
            if(h < 0 || h > 23) return;
            hour = h;
        }
    /**
    <!--
        // private 제어자를 통해서 변수의 값을 직접 변경하지 못하게 하고,
        // 대신 메서드를 통해서 값을 변경하게 만듭니다.
        // 이후 값을 변경할 때 지정된 값의 유효성을 조건문으로 점검한 다음에 유효한 값일 경우에만 변경합니다.
    
        //캡슐화
            // 변수에 직접 접근하는 것을 제한하여 변수의 값을 보호하고, 클래스 외부에서의 부적절한 접근을 방지합니다.
            // 이는 코드의 안정성과 유지보수성을 높입니다.
    
        // 유효성 검사
            // setter를 사용하여 변수의 값을 변경할 때, 특정 조건을 검사하고 유효한 값만 변수에 저장할 수 있습니다.
            // 이를 통해 변수에 유효하지 않은 값이 저장되는 것을 방지할 수 있습니다.
    
        // 코드 변경 유연성
            // 변수에 직접 접근하지 않고 getter와 setter를 사용하면, 내부 구현을 변경하거나 추가적인 로직을 적용하기 쉬워집니다.
            // 예를 들어, 변수 값을 가져올 때 특정 조건에 따라 가공한 값을 반환하거나, 변수 값을 변경하기 전에 로깅 또는 이벤트 처리를 추가할 수 있습니다.
    -->
    **/
        public static void main(String[] args) {
    
        }
    }

    
───────────────────────────────────────────────────────────────────────────────────────────────
<클래스 변수와 인스턴스 변수>
<!-- ObjectAndClass2 -->

public class Main {

    public static void main(String[] args) {

        System.out.println("Card.width = " + Card.width);
        System.out.println("Card.width = " + Card.height);


        Card c1 = new Card();
        c1.kind = "Heart";
        c1.number = 7;


        Card c2 = new Card();
        c2.kind = "spade";
        c2.number = 4;


        System.out.println(
                "c1은" + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")"
        ); /** c1은Heart, 7이며, 크기는 (100, 250) **/

        System.out.println(
                "c2은" + c1.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")"
        ); /** c2은Heart, 4이며, 크기는 (100, 250) **/

        /** <!-- 중요!! --> **/
        /** <!-- 클래스 변수의 값을 변경합니다 --> **/
        c1.width = 50;
        c1.height = 80;

        System.out.println(
                "c1은" + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")"
        ); /** c1은Heart, 7이며, 크기는 (50, 80) **/

        System.out.println(
                "c2은" + c1.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")"
        ); /** c2은Heart, 4이며, 크기는 (50, 80) **/

        /**
        <!--
            c1의 width값을 바꿧지만 c2의 width값까지 바뀌는 이유는
            width,height가 Card클래스의 변수이기 때문입니다.
            Card의 인스턴스인 c1과 c2는 클래스 변수(static)인 width와 height를 공유하기 때문에
            c1의 width(height)를 변경하면 c2의 width(height)도 바뀐 것과 같은 결과를 얻습니다.
            
            이러한 이유때문에 클래스 변수를 사용할 때는 클래스명.클래스변수의 형태로 사용하는 것이 좋습니다.
        -->
        **/


    }
}

class Card {
    String kind;
    int number;
    static int width = 100;
    static int height = 250;
}

/**
<!--
    이 함수를 public static void main(String[] args) {
    위에 올려서 Main 위로 올린뒤로 클래스를 미리 보여서 가독성을 높이려고 시도했는데 안되는것을 발견
    이는 static클래스를 선언할 시 인스턴스를 생성할 수 없기때문이라고 합니다.

    static?
        static int width = 100; / static int height = 250; <= static이므로
        Card c1 = new Card(); <= 이것과 같이 인스턴스를 생성할 수 없음
    
    그 대신, static선언한 변수는 인스턴스를 생성하지 않아도 Card.weight처럼 사용할 수 잇습니다.

    또한 반대로 static을 빼버리고 int width = 100; 처럼 선언할시 내부에 선언하여 인스턴스를 만들 수 있습니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<Method>
    public class Main {
        public static void main(String[] args) {
            MyMath mm = new MyMath(); // 인스턴스 생성
            long result1 = mm.add(5, 3);
            long result2 = mm.subStract(5, 3);
            long result3 = mm.multiply(5, 3);
            double result4 = mm.divide(5, 3); // long타입은 소수점을 출력할 수 없기 때문에 double로 선언
    
            System.out.println("add(5, 3) = " + result1);
            System.out.println("subStract(5, 3) = " + result2);
            System.out.println("multiply(5, 3) = " + result3);
            System.out.println("divide(5, 3) = " + result4);
    
            <!-- 이런식으로 바로 호출해서 사용할 수도 있습니다. -->
            System.out.println(mm.add(5,3));
    
    
        }
    }
    /** <!-- 사칙연산을 위한 4개의 메서드 MyMath --> **/
    class MyMath{
        int c = 0;
        long add(long a, long b){ // 더하기
            long result = a + b;
            return result;

            /**
            <!--
                return a + b;
                위의 두줄을 이와 같이 한 줄로 간단히 할 수 있다.
            -->
            **/
        }
        long subStract(long a, long b){ // 빼기
            return a - b;
        }
        long multiply(long a, long b){ // 곱하기
            return a * b;
        }
        double divide(double a, double b){ // 나누기
            return a / b;
        }
    }

───────────────────────────────────────────────────────────────────────────────────────────────
<CallStack>
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello!");
    }
}
/**
<!--
    1. 위의 예제를 실행시키면 JVM에 의해서 main 메서드가 호출됨으로써 프로그램이 시작됩니다.

            │               │
            │               │
            │               │
            │               │
            └───────────────┘


    2. 이때, 호출스택에서는 AMIN 메서드를 위한 메모리 공간이 할당되고 main메서드의 코드가 수행되기 시작한다
            │               │
            │               │
            │               │
            │      main     │
            └───────────────┘


    3. main 메서드에서 println()을 호출한 상태. 아직 main 메서드가 끝난 것이 아니므로,
        main 메서드는 호출스택에 대기상태로 남아있고 println()의 수행이 시작된다.
        println메서드에 의해 hello가 화면에 출력된다.
            │               │
            │               │
            │    println    │
            │     main      │
            └───────────────┘


    4. println메서드의 수행이 완료되어 호출스택에서 사라지고, 자신을 호출한 main메서드로 되돌아간다
        대기중이던 main메서드는 (println)을 호출한 이후부터 수행을 재개한다.

            │               │
            │               │
            │               │
            │      main     │
            └───────────────┘


    5. main메서드에도 더 이상 수행할 코드가 없으므로 종료되어,
        호출스택은 완전히 비워지게 되고 프로그램은 종료된다.

            │               │
            │               │
            │               │
            │               │
            └───────────────┘


    호출스택을 조사해보면 메서드간의 호출 관계와 현재 수행중인 메서드가 어느 것인지 알 수 있습니다.
    호출스택의 특징을 정리해보면 다음과 같습니다.

    - 호출스택을 조사해 보면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
    - 메서드가 수행을 마치고 나면 사용했던 메모리를 반환하고 스택에서 제거된다.
    - 호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이다.
    - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

    반환타입(return type)이 있는 메서드는 종료되면서 결과값을 자신을 호출한 메서드(caller)에게 반환한다.
    대기상태에 있던 호출한 메서드(caller)는 넘겨받은 반환값으로 수행을 계속 진행하게 됩니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<PrimitiveParameters(기본형 매개변수)>
    class Data { int x; }
public class Main {
    public static void main(String[] args) {
    /**
    <!--
        매개변수에는 기본형 매개변수와 참조형 매개변수가 있습니다

        기본형 매개변수
            변수의 값을 읽기만 할 수 있다.(read only)

         참조형 매개변수
            변수의 값을 읽고 변경할 수 있다. (read & wrtie)

        메서드의 매개변수를 기본형으로 선언하면 단순히 저장된 값만 얻지만,
        참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어오는 것은 물론 값을 변경하는 것도 가능하다.
    -->
    **/

        Data d = new Data(); // 인스턴스 d 생성
        d.x = 10;
        System.out.println("main() : x = " + d.x);

        change(d.x);

        /**
        <!--
            // 1. change 메서드가 실행되면서 'd.x(10)'가 change메서드의 매개변수 x에 복사됨

            │               │
            │    change     │
            │   x(10)       │  ◀───────┐
            ├───────────────│           │
            │     main      │           │
            │   d(0x100)    │  ───▶  x(10)
            └───────────────┘

            // 2. change 메서드에서 x의 값을 1000으로 변경

            │               │
            │    change     │
            │   x(1000)     │
            ├───────────────│
            │     main      │
            │   d(0x100)    │  ───▶  x(10)
            └───────────────┘

            // 3. change 메서드가 종료되면서 매개변수 x는 스택에서 제거됨

            ├───────────────│
            │     main      │
            │   d(0x100)    │  ───▶  x(10)
            └───────────────┘

            이 과정에서 중요한 것은 'd.x의 값이 변경된 것이 아니라. change메서드의 매개변수 x의 값이 변경된 것
            즉, 원본이 아닌 복사본이 변경된 것이라 원본에는 아무런 영향을 미치지 못합니다.
            이처럼 기본형 매개변수는 변수에 저장된 값만 읽을 수 있을 뿐 변경할 수는 없습니다.
        -->
        **/

    }
    static void change(int x){ // 기본형 매개변수
        x = 1000;
        System.out.println("chane() : x = " + x);
    }
}

───────────────────────────────────────────────────────────────────────────────────────────────
<ReferencedParameters(참조형 매개변수)>
    class Data2 { int x; }
    public class Main {
        public static void main(String[] args) {
            Data2 d = new Data2();
            d.x = 10;
            System.out.println("main() : x = " + d.x);
            change(d); /** 이 부분이 다릅니다. d.x => d **/
            System.out.println("After change(d)");
    
            System.out.println("main() : x = " + d.x);
        }
        static void change(Data2 d){
            d.x = 1000;
            System.out.println("change() : x = " + d.x);
        }
    }
    /**
    <!--
        이전과 달리 change메서드를 호출한 후에 d.x의 값이 변경되었습니다.
        1. change메서드가 호출되면서 참조변수 d의 값(주소)이 매개변수 d에 복사됨.
           이제 매개변수 d에 저장된 주소값으로 x에 접근이 가능해집니다.

             │ change        │
             │   d(0x100)    │
             ├────── ▲ ──────┤
             │       ↑       │
             │ main  │       │      0x100
             │   d(0x100)    │ ───▶ x(10)
             └───────────────┘

        2. change메서드에서 매개변수 d로 x의 값을 1000으로 변경.

             │ change        │
             │   d(0x100)    │ ───────┐
             ├───────────────┤        ↓
             │ main          │      0x100
             │   d(0x100)    │ ───▶ x(1000)
             └───────────────┘

        3. change메서드가 종료되면서 매개변수 d는 스택에서 제거됨.

             ┌───────────────┐
             │ main          │      0x100
             │   d(0x100)    │ ───▶ x(1000)
             └───────────────┘
        이전 예제와 달리 change메서드의 매개변수를 참조형으로 선언햇기 때문에
        x의 값이 아닌 변수 d의 주소가 매개변수 d에 복사되었습니다.
        이제 main메서드의 참조변수 d와 change메서드의 참조변수d는 같은 객체를 가리키게 됩니다.
        따라서 매개변수 d로 x의 값을 읽는 것과, 변경이 가능한 것입니다.
    -->
    **/
───────────────────────────────────────────────────────────────────────────────────────────────
<ReferencedParametersReturnType(참조형 반환타입)>
class Data3 { int x; }
public class Main {
    public static void main(String[] args) {
        Data3 d = new Data3();
        d.x = 10;
        Data3 d2 = copy(d);

        System.out.println("d.x = " + d.x);
        System.out.println("d.x = " + d2.x);
    }

    static Data3 copy(Data3 d){
        Data3 tmp = new Data3();
        tmp.x = d.x;
        return tmp;
    }
}

/**
<!--
    매개변수 뿐만이 아니라, 반환타입도 참조형이 될 수 있습니다.
    반환타입이 참조형이라는 것은, 반환하는 값의 타입이 참조형이라는 말입니다.
    모든 참조형 타입의 값은 '객체의 주소'입니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<static메서드와 instance메서드>
변수에서 그랬던 것과 같이, 메서드 앞에 static이 붙어 있으면 클래스 메서드이고,
붙어있지 않다면 인스턴스 메서드입니다.

클래스 메서드도 클래스 변수처럼, 객체를 생성하지 않고도 '클래스이름.메서드이름(매개변수)'와 같은 식으로 호출이 가능합니다.
반면에 인스턴스 메서드는 반드시 객체를 생성해야합니다.

<!--
    클래스에 변수명을 선언햇을때 static으로 선언하면
    인스턴스 선언없이 (클래스명.변수명)을 사용가능한 것과 같습니다.
-->

간단하게 설명하자면, 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는 메서드이며
따라서 인스턴스 메서드란 작업을 수행을 하는데 인스턴스 변수를 필요로 하는 메서드입니다.
그런데 인스턴스 변수는 인스턴스(객체)를 생성해야만 만들어지므로,
인스턴스메서드 역시 인스턴스를 생성해야만 호출할 수 있는것 입니다.

반면에 메서드중에는 인스턴스와 관계없는(인스턴스 변수나, 메서드를 사용하지 않는) 메서드를
클래스 메서드(static메서드)로 정의합니다.
───────────────────────────────────────────────────────────────────────────────────────────────
<StaticMethodInstanceMethod(스태틱 메서드와 인스턴스 메서드)>
/**
<!--
    클래스(static) 메서드는 인스턴스 생성 없이 호출가능하다.

    이번에는 같은 기능을 가진 더하기, 빼기, 곱하기, 나누기를
    인스턴스 메서드와 클래스 메서드로 하나씩 설정한 후 사용하는 것으로 알아보겠습니다.
-->
 **/
class MyMath2{
    long a, b;
    long add()      { return a + b; }
    long subtract() { return a - b; }
    long multiply() { return a * b; }
    double divide() { return a / b; }

    static long add(long a, long b){ // 더하기
        return a + b;
    }
    static long subStract(long a, long b){ // 빼기
        return a - b;
    }
    static long multiply(long a, long b){ // 곱하기
        return a * b;
    }
    static double divide(double a, double b){ // 나누기
        return a / (double)b;
    }
}
public class Main {
    public static void main(String[] args) {
        System.out.println(MyMath2.add(200, 100));
        System.out.println(MyMath2.subStract(200, 100));
        System.out.println(MyMath2.multiply(200, 100));
        System.out.println(MyMath2.divide(200, 100));

        MyMath2 mm = new MyMath2(); // 인스턴스를 생성
        mm.a = 200;
        mm.b = 100;
        System.out.println(mm.add());
        System.out.println(mm.subtract());
        System.out.println(mm.multiply());
        System.out.println(mm.divide());
    }
}

/**
<!--
    이와 같이 static으로 선언한 메서드는 클래스를 생성한순간 클래스명.메서드명으로 사용이 가능하지만
    인스턴스로 선언한 메서드는 인스턴스를 생성하기 전에는 사용할 수 없는것을 볼 수 있습니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<CallsMethods(메서드간의 호출)>
    

public class Main {
    static class TestClass1{
        void instanceMethod(){}      // 인스턴스 메서드
        static void staticMethod(){} // static메서드

        void instanceMethod2(){      // 인스턴스 메서드
            instanceMethod();        // 다른 인스턴스 메서드를 호출한다.
            staticMethod();          // 다른 statice메서드를 호출한다.
        }

        static void staticMethod2(){ // static메서드
            // instanceMethod();        // Error! 클래스 메서드는 인스턴스 메서드를 호출할 수 없다
            staticMethod();          // statice메서드는 호출할 수 있다.
        }
    }
/**
<!--
 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않더라도 서로 참조 또는 호출이 가능합니다.
 그러나, 클래스멤버가 인스턴스 멤버를 호출하는 경우에는 인스턴스를 생성해야합니다.

 그 이유는 인스턴스 멤버가 존재하는 시점에서 클래스 멤버는 항상 존재하지만,
 클래스 멤버가 존재한다고해서 인스턴스 멤버가 존재하지 않을 수도 있기 때문입니다.
-->
**/
/**============================================================**/


    // 이번에는 변수와 메서드간의 호출에 대해서 확인해봅시다.
    class TestClass2{
        int iv;         // 인스턴스 변수
        static int cv;  // 클래스 변수

        void instanceMethod(){      // 인스턴스메서드
            System.out.println(iv); // 인스턴스 변수를 사용할 수 있다
            System.out.println(cv); // 클래스 변수를 사용할 수 있다.
        }

        static void staticMethod(){ // static메서드
            // System.out.println(iv); // Error! 인스턴스 변수를 사용할 수 없다
            System.out.println(cv); // 클래스 변수를 사용할 수 있다.
        }
    }

    public static void main(String[] args) {
        TestClass2.staticMethod(); // 같은 Main 클래스 내의 static메서드는 사용이 가능합니다.

        // TestClass2.instanceMethod(); // 같은 클래스 내부라도 static 클래스 내부에서 다른 클래스의 인스턴스에 접근할 수 없습니다.
        // 접근방법
        Main mainInstance = new Main();
        TestClass2 aaa = mainInstance.new TestClass2();
        aaa.instanceMethod();
        /**
        <!--
            1. 먼저 기본이되는 Main 메서드를 생성합니다.
            2. Main 인스턴스 안의 TestClass2 클래스를 참조하는 aaa 인스턴스를 생성합니다.
            3. 생성한 인스턴스를 참조하여 메서드를 실행합니다.

            이러한 방법은 스태틱만 사용하는 방법에 비해 호출속도가 느리니
            복잡하지 않은 간단한 메서드는 static을 사용하는것을 권장합니다.
        -->
        **/

    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<OverLoading(오버로딩)>
/**
<!--
    메서드도 변수와 마찬가지로 같은 클래스 내에서 서로 구별될 수 있어야 합니다.

    그러나 자바에서는 한클래스 내에 이미 사용하려는 이름과 같은 메서드가 있더라도
    매개변수의 개수, 또는 타입이 다르면 같은 이름을 사용해서 메서드를 정의할 수 있습니다.

    이처럼, 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을
    메서드 오버로딩(Method OverLoading)이라고 합니다.

    오버로딩이 성립하기 위해서는 다음과 같은 조건을 만족해야 합니다.

        1. 메서드의 이름이 같아야 한다.
        2. 매개변수의 개수 또는 타입이 달라야 한다. (같다면 이미 있는 메서드라고 에러를 출력)
        3. 반환 타입은 관계 없다.
 
    ※ 부모클래스의 메서드를 자식클래스에서 재정의하는 Override개념과 혼동하지 않도록 주의
-->
**/
public class Main {
    public static void main(String[] args) {
        MyMath mm = new MyMath();
        System.out.println("mm.add(3, 3) 결과 : " + mm.add(3,3));
        System.out.println("mm.add(3L, 3) 결과 : " + mm.add(3L,3));
        System.out.println("mm.add(3, 3L) 결과 : " + mm.add(3,3L));
        System.out.println("mm.add(3L, 3L) 결과 : " + mm.add(3L,3L));

        int[] a = {100, 200, 300};
        System.out.println("mm.add(a) 결과 : " + mm.add(a));
    }
}
class MyMath{
    int add(int a, int b){
        System.out.print("int add(int a, int b) - ");
        return a + b;
    }

    long add(int a, long b){
        System.out.print("int add(int a, int b) - ");
        return a + b;
    }

    long add(long a, int b){
        System.out.print("long add(long a, int b) - ");
        return a + b;
    }

    long add(long a, long b){
        System.out.print("long add(long a, int b) - ");
        return a + b;
    }

    int add(int[] a){ // 배열의 모든 요소의 합을 결과로 돌려준다
        System.out.print("int adD(int[] a) - ");
        int result = 0;
        for(int i = 0; i < a.length; i++){
            result += a[i];
        }
        return result;

    }
}
───────────────────────────────────────────────────────────────────────────────────────────────
<DefaultConstructor(기본 생성자)>
/**
<!--
    모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 합니다.

    지금까지 생성자를 모르고 프로그래밍을 해왓지만 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는
    컴파일러가 제공하는 기본 생성자(Default Constructor) 덕분입니다.
 
    컴파일을 할 때 소스파일(~.java)의 클래스에 생성자가 하나도 정의되지 않을 경우
    컴파일러는 자동적으로 아래와 같은 내용의 기본 생성자를 추가하여 컴파일을 합니다.
 
        클래스이름(){} => 기본생성자
        Main(){}     => Main클래스의 기본 생성자
-->
**/

class Data_1{
    int value;
}
class Data_2{
    int value;

    Data_2(int x){ // 매개 변수가 있는 생성자
        value = x;
    }
}
public class Main {
    public static void main(String[] args) {
        Data_1 d1 = new Data_1();
        // Data_2 d2 = new Data_2(); // compile error 발생
        Data_2 d2 = new Data_2(10); // 에러 발생하지않음
    }
}
/**
<!--
    이 예제를 보면 Data_2 d2 = new Data_2();에서 오류가 생기는 이유는
    Data_2(int x){ // 매개 변수가 있는 생성자
       value = x;
    }
    이렇게 직접 생성자를 생성하기 전에는 컴파일러가 자동으로 Data_2(){}라는 생성자를 추가해 주었지만
    직접 생성한 후에는 생성자가 있으므로 자동으로 생성자가 추가되지 않았는데
    만든 생성자의 매개변수 int x요소를 넣어주지 않아 오류가 발생합니다.
    따라서 위의 경우처럼 직접 만든 생성자에 맞는 매개변수를 넣어줄경우 오류가 발생하지 않습니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<ConstructorsParameters(매개변수가 있는 생성자)>
class Car{
    String color;       // 색상
    String gearType;    // 변속기의 종류
    int door;           // 문의 개수

    Car(){}

    Car(String c, String g, int d){
        color = c;
        gearType = g;
        door = d;
    }
}
public class Main {
    public static void main(String[] args) {
        Car c1 = new Car();
        c1.color = "white";
        c1.gearType = "auto";
        c1.door = 4;

        Car c2 = new Car("white", "auto", 4);
        System.out.println(
                "c1의 color = " + c1.color + ", gearType = " + c1.gearType + ", door의 개수 = " + c1.door
        );
        System.out.println(
                "c1의 color = " + c2.color + ", gearType = " + c2.gearType + ", door의 개수 = " + c2.door
        );
    }
}
/**
<!--
    c1, c2 두개의 생성방식이 있지만
    c1보다 c2의 생성방식이 조금 더 간결하고 직관적으로 보이는걸 확인할 수 있습니다.
    
    여기서 만약 Car(){}의 코드를 없앤다면 
    Car(String c, String g, int d) 생성자가 있기때문에
    Car(){}라는 기본 생성자가 생성되지 않아
    Car c1 = new Car();의 인스턴스 생성이 불가능해집니다.
-->
**/
───────────────────────────────────────────────────────────────────────────────────────────────
<ConstructorThis(생성자에서 다른 생성자 호출하기)>
/**
<!--
    생성자에서 다른 생성자를 호출할때의 규칙
    생성자의 이름으로 클래스명 대신 this를 사용한다.
    한 생성자에서 다른 생성자를 호출할 때는 반드시 첫줄에서만 호출이 가능하다.

    다른 생성자를 첫줄에서만 호출이 가능한 이유는
    생성자 내에서 초기화 작업도중 다른생성자를 호출하게 되면
    호출된 다른 생성자 내의 멤버변수 값을 초기화 할 수 있기 때문입니다.(사실잘모름)

    생성자를 호출할 때는 this(매개변수)가 들어가게 되는데
    클래스명이아닌 매개변수를 통해 그와 똑같은 생성자를 찾습니다.
-->
**/

class Car{
    String color;       // 색상
    String gearType;    // 변속기의 종류 auto(자동), manual(수동)
    int door;           // 문의 개수

    Car(){
        this("white", "auto", 4);
    }

    Car(String color){
        this(color, "auto", 4);
    }
    Car(String c, String g, int d){
        this.color = c;
        this.gearType = g;
        this.door = d;
    }
}
public class Main {
    public static void main(String[] args) {
        Car c1 = new Car();
        Car c2 = new Car("blue");
                System.out.println(
                "c1의 color = " + c1.color + ", gearType = " + c1.gearType + ", door의 개수 = " + c1.door
        );
        System.out.println(
                "c1의 color = " + c2.color + ", gearType = " + c2.gearType + ", door의 개수 = " + c2.door
        );
    }
}
/**
<!--
    이 방식은 마치 실생활에서 자동차(Car인스턴스)를 생성할 때, 아무런 옵션을 주지 않으면
    기본적으로 흰색(white), 자동변속기어(auto), 문의 개수(4개)인 자동차를 생산하는 것에 비유할 수 있습니다.
-->
 **/
───────────────────────────────────────────────────────────────────────────────────────────────